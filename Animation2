-- Gui to Lua
-- Version: 3.2

-- Instances:

local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local TextLabel = Instance.new("TextLabel")
local Reanimate = Instance.new("TextButton")
local Krystal = Instance.new("TextButton")
local Kekw = Instance.new("TextButton")
local Sonc = Instance.new("TextButton")
local Memeis = Instance.new("TextButton")
local snas = Instance.new("TextButton")
local Chara = Instance.new("TextButton")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Frame.Position = UDim2.new(0.0806916356, 0, 0.132283464, 0)
Frame.Size = UDim2.new(0, 525, 0, 293)

TextLabel.Parent = Frame
TextLabel.BackgroundColor3 = Color3.fromRGB(13, 13, 13)
TextLabel.Position = UDim2.new(-0.000285424292, 0, -0.00203023851, 0)
TextLabel.Size = UDim2.new(0, 525, 0, 35)
TextLabel.Font = Enum.Font.GothamBold
TextLabel.Text = "googa333s' Animation GUI v2"
TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextSize = 35.000

Reanimate.Name = "Reanimate"
Reanimate.Parent = Frame
Reanimate.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Reanimate.Position = UDim2.new(0, 0, 0.201832801, 0)
Reanimate.Size = UDim2.new(0, 525, 0, 44)
Reanimate.Font = Enum.Font.SourceSans
Reanimate.Text = "Turn animations into FE"
Reanimate.TextColor3 = Color3.fromRGB(0, 0, 0)
Reanimate.TextSize = 25.000
Reanimate.MouseButton1Down:connect(function()
	spawn(function()
		while true do
			game.Players.LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)*math.huge
			game.Players.LocalPlayer.SimulationRadius = math.pow(math.huge,math.huge)*math.huge
			game:GetService("RunService").Stepped:wait()
		end
	end)
	game["Run Service"].Stepped:connect(function()
		game.Players.LocalPlayer.Character.Tors.CanCollide = false
		game.Players.LocalPlayer.Character.Head.CanCollide = false
	end)
	game.Players.LocalPlayer.CharacterAdded:connect(function()
		game.Players.LocalPlayer.Character:WaitForChild("Right Arm")
		wait(0.1)
		rs = game.Players.LocalPlayer.Character.Torso["Right Shoulder"]:Clone()
		game.Players.LocalPlayer.Character.Torso["Right Shoulder"]:Destroy()
		rs.Parent = game.Players.LocalPlayer.Character.Torso
		rs.Part0 = game.Players.LocalPlayer.Character.Torso
		rs.Part1 = game.Players.LocalPlayer.Character["Right Arm"]:Clone()
		game.Players.LocalPlayer.Character["Right Arm"].Name = "ra"
		rs.Part1.Parent = game.Players.LocalPlayer.Character
		local Attachment0 = Instance.new("Attachment", game.Players.LocalPlayer.Character["Right Arm"])
		local rightarm = Instance.new("Attachment", game.Players.LocalPlayer.Character["ra"])
		local ol = Instance.new("HingeConstraint", game.Players.LocalPlayer.Character["Right Arm"])
		ol.Attachment0 = Attachment0
		ol.Attachment1 = rightarm
		ol.LimitsEnabled = true
		ol.LowerAngle = 0
		ol.Restitution = 0
		ol.UpperAngle = 0
		ls = game.Players.LocalPlayer.Character.Torso["Left Shoulder"]:Clone()
		game.Players.LocalPlayer.Character.Torso["Left Shoulder"]:Destroy()
		ls.Parent = game.Players.LocalPlayer.Character.Torso
		ls.Part0 = game.Players.LocalPlayer.Character.Torso
		ls.Part1 = game.Players.LocalPlayer.Character["Left Arm"]:Clone()
		game.Players.LocalPlayer.Character["Left Arm"].Name = "la"
		ls.Part1.Parent = game.Players.LocalPlayer.Character
		local Attachment0 = Instance.new("Attachment", game.Players.LocalPlayer.Character["Left Arm"])
		local rightarm = Instance.new("Attachment", game.Players.LocalPlayer.Character["la"])
		local ol = Instance.new("HingeConstraint", game.Players.LocalPlayer.Character["Left Arm"])
		ol.Attachment0 = Attachment0
		ol.Attachment1 = rightarm
		ol.LimitsEnabled = true
		ol.LowerAngle = 0
		ol.Restitution = 0
		ol.UpperAngle = 0
		rh = game.Players.LocalPlayer.Character.Torso["Right Hip"]:Clone()
		game.Players.LocalPlayer.Character.Torso["Right Hip"]:Destroy()
		rh.Parent = game.Players.LocalPlayer.Character.Torso
		rh.Part0 = game.Players.LocalPlayer.Character.Torso
		rh.Part1 = game.Players.LocalPlayer.Character["Right Leg"]:Clone()
		game.Players.LocalPlayer.Character["Right Leg"].Name = "rh"
		rh.Part1.Parent = game.Players.LocalPlayer.Character
		local Attachment0 = Instance.new("Attachment", game.Players.LocalPlayer.Character["Right Leg"])
		local rightarm = Instance.new("Attachment", game.Players.LocalPlayer.Character["rh"])
		local ol = Instance.new("HingeConstraint", game.Players.LocalPlayer.Character["Right Leg"])
		ol.Attachment0 = Attachment0
		ol.Attachment1 = rightarm
		ol.LimitsEnabled = true
		ol.LowerAngle = 0
		ol.Restitution = 0
		ol.UpperAngle = 0
		lh = game.Players.LocalPlayer.Character.Torso["Left Hip"]:Clone()
		game.Players.LocalPlayer.Character.Torso["Left Hip"]:Destroy()
		lh.Parent = game.Players.LocalPlayer.Character.Torso
		lh.Part0 = game.Players.LocalPlayer.Character.Torso
		lh.Part1 = game.Players.LocalPlayer.Character["Left Leg"]:Clone()
		game.Players.LocalPlayer.Character["Left Leg"].Name = "lh"
		lh.Part1.Parent = game.Players.LocalPlayer.Character
		local Attachment0 = Instance.new("Attachment", game.Players.LocalPlayer.Character["Left Leg"])
		local rightarm = Instance.new("Attachment", game.Players.LocalPlayer.Character["lh"])
		local ol = Instance.new("HingeConstraint", game.Players.LocalPlayer.Character["Left Leg"])
		ol.Attachment0 = Attachment0
		ol.Attachment1 = rightarm
		ol.LimitsEnabled = true
		ol.LowerAngle = 0
		ol.Restitution = 0
		ol.UpperAngle = 0
		r = game.Players.LocalPlayer.Character.HumanoidRootPart["RootJoint"]:Clone()
		game.Players.LocalPlayer.Character.HumanoidRootPart["RootJoint"]:Destroy()
		r.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
		r.Part0 = game.Players.LocalPlayer.Character.HumanoidRootPart
		r.Part1 = Instance.new("Part", game.Players.LocalPlayer.Character)
		r.Part1.Size = Vector3.new(2,2,1)
		r.Part1.Name = "Tors"
		r.Part1.Parent = game.Players.LocalPlayer.Character
		local Attachment0 = Instance.new("Attachment", game.Players.LocalPlayer.Character.Tors)
		local rightarm = Instance.new("Attachment", game.Players.LocalPlayer.Character.Torso)
		local ol = Instance.new("HingeConstraint", game.Players.LocalPlayer.Character.Tors)
		ol.Attachment0 = Attachment0
		ol.Attachment1 = rightarm
		ol.LimitsEnabled = true
		ol.LowerAngle = 0
		ol.Restitution = 0
		ol.UpperAngle = 0
		char = game.Players.LocalPlayer.Character
		repeat wait()until char:FindFirstChildOfClass("Accessory")
		wait(0.1)
		for i,v in pairs (char:GetChildren()) do
			if v:IsA("Accessory") and v:FindFirstChild("Handle") and v:FindFirstChild("Handle"):FindFirstChild("AccessoryWeld").Part1 == char.Head then
				local Attachment0 = Instance.new("Attachment", char.Head)
				local rightarm = Instance.new("Attachment", v.Handle)
				local ol = Instance.new("HingeConstraint", char.Head)
				ol.Attachment0 = Attachment0
				ol.Attachment1 = rightarm
				ol.LimitsEnabled = true
				ol.LowerAngle = 0
				ol.Restitution = 0
				ol.UpperAngle = 0
				rightarm.CFrame = v.AttachmentPoint + Vector3.new(0, -0.5, 0)
				v.Handle.AccessoryWeld:Destroy()
			end
		end
	end)
	game.Players.LocalPlayer.Character.Humanoid.Health = 0
	while wait() do
		repeat wait() until game.Players.LocalPlayer.Character
		char = game.Players.LocalPlayer.Character
		for i,v in pairs (char:GetDescendants()) do
			if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
				v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0,0,0)
				v.Massless = true
				v.CanCollide = false
			end
		end
	end
end)

Krystal.Name = "Krystal"
Krystal.Parent = Frame
Krystal.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Krystal.Position = UDim2.new(0.123673908, 0, 0.478283256, 0)
Krystal.Size = UDim2.new(0, 110, 0, 44)
Krystal.Font = Enum.Font.SourceSans
Krystal.Text = "Krystal Dance"
Krystal.TextColor3 = Color3.fromRGB(0, 0, 0)
Krystal.TextSize = 20.000
Krystal.MouseButton1Down:connect(function()
	-----------//KRYSTAL DANCE V2\\-----------
--[[Movelist
Q = The Swoosher
E = The nutty
R = Spin me right round!
T = Plum juice dance
Y = Moonwalk
U = Slav dance
P = Barrel roll
F = The Jerky
G = The Shuffle
H = The Spongebob
J = Here comes the money!
K = Runnin' in the 90's
---------]]

	--Krystal dance! The old famous script that sadly has been broken(sorta), i've decided to rework this thing because... nostalgia.--
	--This is one of the first scripts i've ever ran on SB, seeing this back again really reminds me of how much of a noob i was.--
	--Credits to Krystalteam, they made the original krystal dance! Be sure to respect them or else...--
	--#makeoldscriptsgreatagain--

	Player=game.Players.LocalPlayer
	Character=Player.Character
	Character.Humanoid.Name = "noneofurbusiness"
	hum = Character.noneofurbusiness
	LeftArm=Character["Left Arm"]
	LeftLeg=Character["Left Leg"]
	RightArm=Character["Right Arm"]
	RightLeg=Character["Right Leg"]
	Root=Character["HumanoidRootPart"]
	Head=Character["Head"]
	Torso=Character["Torso"]
	Neck=Torso["Neck"]
	mouse = Player:GetMouse()
	walking = false
	jumping = false
	attacking = false
	firsttime = false
	tauntdebounce = false
	position = nil
	MseGuide = true
	running = false
	settime = 0
	sine = 0
	t = 0
	ws = 14
	change = 1
	combo1 = true
	dancing = false
	equip = false
	dgs = 75
	combo2 = false
	switch1 = true
	switch2 = false
	firsttime2 = false
	combo3 = false
	gunallowance = false
	shooting = false
	RunSrv = game:GetService("RunService")
	RenderStepped = game:GetService("RunService").RenderStepped
	removeuseless = game:GetService("Debris")

	screenGui = Instance.new("ScreenGui")
	screenGui.Parent = script.Parent

	local HEADLERP = Instance.new("ManualWeld")
	HEADLERP.Parent = Head
	HEADLERP.Part0 = Head
	HEADLERP.Part1 = Head
	HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local TORSOLERP = Instance.new("ManualWeld")
	TORSOLERP.Parent = Root
	TORSOLERP.Part0 = Torso
	TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local ROOTLERP = Instance.new("ManualWeld")
	ROOTLERP.Parent = Root
	ROOTLERP.Part0 = Root
	ROOTLERP.Part1 = Torso
	ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local RIGHTARMLERP = Instance.new("ManualWeld")
	RIGHTARMLERP.Parent = RightArm
	RIGHTARMLERP.Part0 = RightArm
	RIGHTARMLERP.Part1 = Torso
	RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local LEFTARMLERP = Instance.new("ManualWeld")
	LEFTARMLERP.Parent = LeftArm
	LEFTARMLERP.Part0 = LeftArm
	LEFTARMLERP.Part1 = Torso
	LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local RIGHTLEGLERP = Instance.new("ManualWeld")
	RIGHTLEGLERP.Parent = RightLeg
	RIGHTLEGLERP.Part0 = RightLeg
	RIGHTLEGLERP.Part1 = Torso
	RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local LEFTLEGLERP = Instance.new("ManualWeld")
	LEFTLEGLERP.Parent = LeftLeg
	LEFTLEGLERP.Part0 = LeftLeg
	LEFTLEGLERP.Part1 = Torso
	LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local function weldBetween(a, b)
		local weld = Instance.new("ManualWeld", a)
		weld.Part0 = a
		weld.Part1 = b
		weld.C0 = a.CFrame:inverse() * b.CFrame
		return weld
	end

	function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
		A = Instance.new("Attachment", PARENT)
		A.Position = POSITION1
		A.Name = "A"
		B = Instance.new("Attachment", PARENT)
		B.Position = POSITION2
		B.Name = "B"
		tr1 = Instance.new("Trail", PARENT)
		tr1.Attachment0 = A
		tr1.Attachment1 = B
		tr1.Enabled = true
		tr1.Lifetime = LIFETIME
		tr1.TextureMode = "Static"
		tr1.LightInfluence = 0
		tr1.Color = COLOR
		tr1.Transparency = NumberSequence.new(0, 1)
	end

	introsound = Instance.new("Sound",Head)
	introsound.SoundId = "rbxassetid://236146895"
	introsound.Volume = 8
	introsound:Play()


	fedora = Instance.new("Part",Character)
	fedora.Size = Vector3.new(2,2,2)
	fedora.CFrame = Head.CFrame
	fedora.CanCollide = false
	fedoraweld = Instance.new("Weld",fedora)
	fedoraweld.Part0 = fedora
	fedoraweld.Part1 = Head
	fedoraweld.C0 = fedora.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.75,0)
	mfedora = Instance.new("SpecialMesh", fedora)
	mfedora.MeshType = "FileMesh"
	mfedora.Scale = Vector3.new(.97, .97, .97)
	mfedora.MeshId,mfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'

	shades = Instance.new("Part",Character)
	shades.Size = Vector3.new(2,2,2)
	shades.CFrame = Head.CFrame
	shades.CanCollide = false
	shadesweld = Instance.new("Weld",shades)
	shadesweld.Part0 = shades
	shadesweld.Part1 = Head
	shadesweld.C0 = shades.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.2,.15)
	mshades = Instance.new("SpecialMesh", shades)
	mshades.MeshType = "FileMesh"
	mshades.Scale = Vector3.new(1.04, 1.28, 1.04)
	mshades.MeshId,mshades.TextureId = 'http://www.roblox.com/asset/?id=1577360','http://www.roblox.com/asset/?id=1577349'

	for i,v in pairs(Character:GetChildren()) do
		if v.ClassName == "Shirt" or v.ClassName == "Pants" or v.ClassName == "Hat" or v.ClassName == "CharacterMesh" or v.ClassName == "Shirt Graphic" then
			v:Remove()
		end
	end

	coroutine.wrap(function()
		while wait() do
			Head.face.Texture = "rbxasset://textures/face.png"
			hum.WalkSpeed = ws
			LeftArm.BrickColor = BrickColor.new("Really black")
			RightArm.BrickColor = BrickColor.new("Really black")
			Head.BrickColor = BrickColor.new("White")
			Torso.BrickColor = BrickColor.new("Really black")
			LeftLeg.BrickColor = BrickColor.new("Really black")
			RightLeg.BrickColor = BrickColor.new("Really black")
		end
	end)()
	godmode = coroutine.wrap(function()
		for i,v in pairs(Character:GetChildren()) do
			if v:IsA("BasePart") and v ~= Root then
				v.Anchored = false
			end
		end
		while true do
			hum.MaxHealth = math.huge
			wait(0.0000001)
			hum.Health = math.huge
			wait()
		end
	end)
	godmode()
	ff = Instance.new("ForceField", Character)
	ff.Visible = false

	coroutine.wrap(function()
		for i,v in pairs(Character:GetChildren()) do
			if v.Name == "Animate" then v:Remove()
			end
		end
	end)()

	function damagealll(Radius,Position)		
		local Returning = {}		
		for _,v in pairs(workspace:GetChildren()) do		
			if v~=Character and v:FindFirstChildOfClass('Humanoid') and v:FindFirstChild('Torso') or v:FindFirstChild('UpperTorso') then
				if v:FindFirstChild("Torso") then		
					local Mag = (v.Torso.Position - Position).magnitude		
					if Mag < Radius then		
						table.insert(Returning,v)		
					end
				elseif v:FindFirstChild("UpperTorso") then	
					local Mag = (v.UpperTorso.Position - Position).magnitude		
					if Mag < Radius then		
						table.insert(Returning,v)		
					end
				end	
			end		
		end		
		return Returning		
	end

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"
	script:WaitForChild("Heartbeat")

	frame = 1 / 60
	tf = 0
	allowframeloss = false
	tossremainder = false


	lastframe = tick()
	script.Heartbeat:Fire()


	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function swait(num)
		if num == 0 or num == nil then
			game:service("RunService").Stepped:wait(0)
		else
			for i = 0, num do
				game:service("RunService").Stepped:wait(0)
			end
		end
	end

	for _,n in pairs(Character:GetChildren()) do
		if n:IsA("Accessory") then n:Remove() end
	end
	for _,x in pairs(Character:GetChildren()) do
		if x:IsA("Decal") then x:Remove() end
	end

	intro = true
	ws = 0

	bigfedora = Instance.new("Part",Character)
	bigfedora.Size = Vector3.new(2,2,2)
	bigfedora.CFrame = bigfedora.CFrame:inverse() * Root.CFrame * CFrame.new(math.random(-60,60),-.2,math.random(-60,60)) * CFrame.Angles(0,math.rad(math.random(-180,180)),0)
	bigfedora.CanCollide = false
	bigfedora.Anchored = true
	bigfedora.Name = "mbigf"
	mbigfedora = Instance.new("SpecialMesh", bigfedora)
	mbigfedora.MeshType = "FileMesh"
	mbigfedora.Scale = Vector3.new(6, 7, 7)
	mbigfedora.MeshId,mbigfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("Part") and v.Name ~= "mbigf" then v.Transparency = 1
		end
	end
	for i = 1, 60 do
		bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(Root.Position) * CFrame.new(0,-.1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.09)
		swait()
	end
	wait(.25)
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("Part") and v.Name ~= "mbigf" and v.Name ~= "HumanoidRootPart" then v.Transparency = 0
		end
	end
	for i = 1, 50 do
		bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(fedora.Position),.05)
		swait()
	end
	zmc = 0
	for i = 1, 29 do
		zmc = zmc + 2
		mbigfedora.Scale = mbigfedora.Scale - Vector3.new(.25,.25,.25)
		bigfedora.CFrame = bigfedora.CFrame * CFrame.Angles(math.rad(0),math.rad(zmc),0)
		swait()
	end
	bigfedora:Remove()

	ws = 14

	function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
		so = Instance.new("Sound")
		so.Parent = PARENT
		so.SoundId = "rbxassetid://"..ID
		so.Volume = VOL
		so.Looped = LOOP

		so:Play()
		removeuseless:AddItem(so,REMOVE)
	end

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='k' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				jam = Instance.new("Sound",Torso)
				jam.SoundId = "rbxassetid://665751753"
				jam.Volume = 8
				jam.Looped = true
				jam.TimePosition = 22.3
				jam:Play()
				lol90 = 0
				coroutine.wrap(function()
					while dancing do
						lol90 = lol90 + 11
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(1 * math.sin(sine/10),.1 + .8 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(0 * math.sin(sine/8)),math.rad(8 * math.sin(sine/7))),.25)
						ROOTLERP.C1 = ROOTLERP.C1:lerp(CFrame.new(0 * math.sin(sine/14),0,0) * CFrame.Angles(math.rad(0),math.rad(lol90),0),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-5 * math.sin(sine/3)),math.rad(-6 * math.sin(sine/3))),0.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(5 * math.sin(sine/3)),math.rad(6 * math.sin(sine/3))), 0.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10 + 5 * math.sin(sine/3))), 0.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10 - 5 * math.sin(sine/3))), 0.25)
						swait()
					end
					ws = 14
					jam:Remove()
					ROOTLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='j' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 3
				change = .5
				attacking = true
				g1 = Instance.new("BodyGyro", Root)
				g1.D = 175
				g1.P = 20000
				g1.MaxTorque = Vector3.new(0,9000,0)
				herecomesthemoney = Instance.new("Sound",Torso)
				herecomesthemoney.Pitch = 1
				herecomesthemoney.SoundId = "rbxassetid://2426693638"
				herecomesthemoney.Volume = 8
				herecomesthemoney.Looped = true
				herecomesthemoney:Play()
				robuxpile = Instance.new("Part",Torso)
				robuxpile.Size = Vector3.new(1,1,1)
				robuxpile.CFrame = LeftArm.CFrame
				robuxpile.CanCollide = false
				robuxpileweld = Instance.new("Weld",robuxpile)
				robuxpileweld.Part0 = robuxpile
				robuxpileweld.Part1 = Torso
				robuxpileweld.C0 = robuxpile.CFrame:inverse() * LeftArm.CFrame * CFrame.new(1,-.7,1.4)
				mrobuxpile = Instance.new("SpecialMesh", robuxpile)
				mrobuxpile.MeshType = "FileMesh"
				mrobuxpile.Scale = Vector3.new(0.85, .85, .85)
				mrobuxpile.MeshId,mrobuxpile.TextureId = 'http://www.roblox.com/asset/?id=1285245','http://www.roblox.com/asset/?id=8587344'
				coroutine.wrap(function()
					coroutine.wrap(function()
						while wait(.35) do
							if not dancing then break end
							local robux = Instance.new("Part",Torso)
							robux.CFrame = robuxpile.CFrame * CFrame.Angles(math.rad(0),math.rad(90),math.rad(90))
							robux.Anchored = false
							robux.CanCollide = true
							robux.Size = Vector3.new(1,1,1)
							removeuseless:AddItem(robux,4)
							mrobux = Instance.new("SpecialMesh", robux)
							mrobux.MeshType = "FileMesh"
							mrobux.Scale = Vector3.new(1.25, 1.25, 1.25)
							mrobux.MeshId,mrobux.TextureId = 'http://www.roblox.com/asset/?id=667285348','http://www.roblox.com/asset/?id=665939136'
							bov = Instance.new("BodyVelocity",robux)
							bov.maxForce = Vector3.new(99999,99999,99999)
							robux.CFrame = CFrame.new(robux.Position,mouse.Hit.p)
							bov.velocity = robux.CFrame.lookVector*45
							removeuseless:AddItem(bov,.1)
						end
					end)()
					while dancing do
						g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.3,0) * CFrame.Angles(math.rad(20),math.rad(0 * math.sin(sine/8)),math.rad(0)),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,.5 + .5 * math.sin(sine/2),.5) * CFrame.Angles(math.rad(-97),math.rad(40 - 20 * math.sin(sine/2)),math.rad(0)), 0.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,.5,.5) * CFrame.Angles(math.rad(-87),math.rad(-20),math.rad(0)), 0.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(-10)), 0.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(10)), 0.25)
						swait()
					end
					ws = 14
					removeuseless:AddItem(g1,.001)
					robuxpile:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='h' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				jellyfishjam = Instance.new("Sound",Torso)
				jellyfishjam.SoundId = "rbxassetid://840189092"
				jellyfishjam.Volume = 8
				jellyfishjam.Looped = true
				jellyfishjam.TimePosition = 14.8
				jellyfishjam:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(20)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(0.25, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-35)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(14)), 0.25)
							swait()
						end
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(25), math.rad(-2)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.25)
							swait()
						end
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(-20)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(-0.25, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(35)), 0.25)
							swait()
						end
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.1,0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-14)), 0.3)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(-25), math.rad(-2)), 0.25)
							swait()
						end
						swait()
					end
					ws = 14
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='g' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				deadmau7 = Instance.new("Sound",Torso)
				deadmau7.SoundId = "rbxassetid://168166611"
				deadmau7.Volume = 8
				deadmau7.Looped = true
				deadmau7:Play()
				coroutine.wrap(function()
					coroutine.wrap(function()
						while dancing do
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(2 * math.sin(sine/9),-.4 + .1 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/9)),0),.25)
							swait()
						end
					end)()
					while dancing do
						for i = 1, 28 do
							if not dancing then break end
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, .7,1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(0)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-.1) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(-2)), 0.3)
							swait()
						end
						for i = 1, 28 do
							if not dancing then break end
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,.1) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(-8)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, .7,1.1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(-2)), 0.25)
							swait()
						end
						swait()
					end
					ws = 14
					deadmau7:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='f' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 6
				change = .5
				attacking = true
				bennyhill = Instance.new("Sound",Torso)
				bennyhill.SoundId = "rbxassetid://138211362"
				bennyhill.Volume = 8
				bennyhill.Looped = true
				bennyhill:Play()
				coroutine.wrap(function()
					while dancing do
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.4,0) * CFrame.Angles(math.rad(20 + 5 * math.sin(sine/2)),math.rad(10 * math.sin(sine/4)),0),.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.89 - .4 * -math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70 + 20 * -math.sin(sine/2)),0,math.rad(0)),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.89 - .4 * math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70  + 20 * math.sin(sine/2)),0,math.rad(0)),.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, -.2 + .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * -math.sin(sine/2)), math.rad(0), math.rad(-8)), 0.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0,-.2 - .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * math.sin(sine/2)), math.rad(0), math.rad(8)), 0.25)
						swait()
					end
					ws = 14
					bennyhill:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='p' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				barrelspin = 0
				barrelrollsound = Instance.new("Sound",Torso)
				barrelrollsound.SoundId = "rbxassetid://505320170"
				barrelrollsound.Volume = 8
				barrelrollsound.Looped = true
				barrelrollsound:Play()
				barrol = Instance.new("Part",Torso)
				barrol.Size = Vector3.new(1,1,1)
				barrol.CFrame = Torso.CFrame
				barrol.CanCollide = false
				barrolweld = Instance.new("Weld",barrol)
				barrolweld.Part0 = barrol
				barrolweld.Part1 = Torso
				barrolweld.C0 = barrol.CFrame:inverse() * Torso.CFrame * CFrame.new(0,0,0)
				mbarrol = Instance.new("SpecialMesh", barrol)
				mbarrol.MeshType = "FileMesh"
				mbarrol.Scale = Vector3.new(1.05, .95, 1.05)
				mbarrol.MeshId,mbarrol.TextureId = 'http://www.roblox.com/asset/?id=29873142','http://www.roblox.com/asset/?id=31082268'
				coroutine.wrap(function()
					while dancing do
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(5 * math.sin(sine/8),-1.8,0) * CFrame.Angles(math.rad(-90),math.rad(180 * math.sin(sine/8)),0),.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(0,0,0),.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-.5,2,0) * CFrame.Angles(0,0,0),.25)
						swait()
					end
					ws = 14
					barrol:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='q' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				spinningmove = 0
				dbwouldlovethis = Instance.new("Sound",Torso)
				dbwouldlovethis.SoundId = "rbxassetid://1532157598"
				dbwouldlovethis.Volume = 8
				dbwouldlovethis.Looped = true
				dbwouldlovethis:Play()
				attacking = true
				coroutine.wrap(function()
					while dancing do
						spinningmove = spinningmove + 10
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.9, -.35) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)),.2)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.9, .35) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
						ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.2 * math.sin(sine/3), -.52, .2 * math.sin(sine/4)) * CFrame.Angles(math.rad(180),math.rad(spinningmove),math.rad(15 * math.sin(sine/9))),.2)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-1),math.rad(-3 * math.sin(sine/2))),0.3)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(1),math.rad(3 * math.sin(sine/2))), 0.3)
						swait()
					end
					ws = 14
					dbwouldlovethis:Remove()
					attacking = false
				end)()
			end
		end
	end)


	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='u' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 6
				change = .5
				attacking = true
				slavdance = Instance.new("Sound",Torso)
				slavdance.SoundId = "rbxassetid://2341226836"
				slavdance.Volume = 6
				slavdance.Looped = true
				slavdance:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 17 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
							swait()
						end
						for i = 1, 17 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
							swait()
						end
						swait()
					end
					ws = 14
					slavdance:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='y' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				walkforward = 0
				walkrotation = 0
				attacking = true
				truelegend = Instance.new("Sound",Torso)
				truelegend.SoundId = "rbxassetid://487872908"
				truelegend.TimePosition = 13.98
				truelegend.Volume = 8
				truelegend.Looped = true
				truelegend:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 100 do
							if not dancing then break end
							walkforward = walkforward + .1
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
							swait()
						end
						for i = 1, 50 do
							if not dancing then break end
							walkrotation = walkrotation + 15
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
							swait()
						end
						walkrotation = 0
						for i = 1, 100 do
							if not dancing then break end
							walkforward = walkforward - .1
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(-180),math.rad(-0)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,.7,.2) * CFrame.Angles(math.rad(220),math.rad(0),math.rad(-30)), 0.4)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
							swait()
						end
						for i = 1, 50 do
							if not dancing then break end
							walkrotation = walkrotation + 15
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.1)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
							swait()
						end
						walkrotation = 0
						swait()
					end
					ws = 14
					truelegend:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='t' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				plummusic = Instance.new("Sound",Torso)
				plummusic.Volume = 8
				plummusic.Looped = true
				plummusic.SoundId = "rbxassetid://2526093213"
				plummusic:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 20 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2 , .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,1.98,.05) * CFrame.Angles(0,0,math.rad(-140)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,1.3,.05) * CFrame.Angles(0,0,math.rad(50)),.2)
							swait()
						end
						for i = 1, 20 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(-15)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,1.4,.05) * CFrame.Angles(0,0,math.rad(-50)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(-.6,2,.05) * CFrame.Angles(0,0,math.rad(140)),.2)
							swait()
						end
						swait()
					end
					ws = 14
					plummusic:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='e' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				mrozo = Instance.new("Sound",Torso)
				mrozo.Volume = 8
				mrozo.SoundId = "rbxassetid://335701357"
				mrozo.Looped = true
				mrozo.TimePosition = 10
				mrozo:Play()
				coroutine.wrap(function()
					while dancing do
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.1)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.1)
						ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15*math.sin(sine/4))),.2)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3 + .3 * math.sin(sine/3.5),.5 * -math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3 + .3 * math.sin(sine/3.5),.5 * math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
						swait()
					end
					mrozo:Remove()
					ws = 14
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='r' then
			if dancing then
				dancing = false
			else
				ws = 6
				recordbaby = 0
				dancing = true
				change = .5
				attacking = true
				spinme = Instance.new("Sound",Torso)
				spinme.Volume = 8
				spinme.SoundId = "rbxassetid://145799973"
				spinme.Looped = true
				spinme:Play()
				coroutine.wrap(function()
					while dancing do
						recordbaby = recordbaby + 10
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.27, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.27, 2.0, -.1 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
						ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.5 * math.sin(sine/5), -.2, .5 * math.sin(sine/4)) * CFrame.Angles(math.rad(0),math.rad(recordbaby),math.rad(0)),.3)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.5,1.98,0) * CFrame.Angles(0,0,math.rad(-90)),.3)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.5,1.98,0) * CFrame.Angles(0,0,math.rad(90)),.3)
						swait()
					end
					spinme:Remove()
					ws = 14
					attacking = false
				end)()
			end
		end
	end)

	function ray(pos, dir, rang, ignoredesc)
		return workspace:FindPartOnRay(Ray.new(pos, dir.unit * rang), ignoredesc)
	end

	function ray2(startpos, endpos, distance, ignore)
		local dir = CFrame.new(startpos,endpos).lookVector
		return ray(startpos, dir, distance, ignore)
	end

	checks1 = coroutine.wrap(function() -------Checks
		while true do
			hf = ray(Root.Position,(CFrame.new(Root.Position,Root.Position+Vector3.new(0,-1,0))).lookVector,3*3,Character)
			if Root.Velocity.y > 1 then
				position = "Jump"
			elseif Root.Velocity.y < -1 then
				position = "Falling"
			elseif Root.Velocity.Magnitude < 2 then
				position = "Idle"
			elseif Root.Velocity.Magnitude > 2 then
				position = "Walking"
			elseif Root.Velocity.Magnitude > 20 then
				position = "Running"
			else
			end
			wait()
		end
	end)
	checks1()

	function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function ray2(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
		return ray(StartPos, DIRECTION, Distance, Ignore)
	end

	OrgnC0 = Neck.C0
	local movelimbs = coroutine.wrap(function()
		while RunSrv.RenderStepped:wait() do
			TrsoLV = Torso.CFrame.lookVector
			Dist = nil
			Diff = nil
			if not MseGuide then
				print("Failed to recognize")
			else
				local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
				Dist = (Head.CFrame.p-Point).magnitude
				Diff = Head.CFrame.Y-Point.Y
				local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
				Dist2 = (LeftArm.CFrame.p-Point).magnitude
				Diff2 = LeftArm.CFrame.Y-Point.Y
				HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
				Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
			end
		end
	end)
	movelimbs()
	immortal = {}
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
			if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
				v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			end
			table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
		elseif v:IsA("JointInstance") then
			table.insert(immortal,{v,v.Parent,nil,nil,nil})
		end
	end
	for e = 1, #immortal do
		if immortal[e] ~= nil then
			local STUFF = immortal[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if levitate then
				if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
					PART.Material = MATERIAL
					PART.Color = COLOR
					PART.Transparency = TRANSPARENCY
				end
				PART.AncestryChanged:connect(function()
					PART.Parent = PARENT
				end)
			else
				if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
					PART.Material = MATERIAL
					PART.Color = COLOR
					PART.Transparency = TRANSPARENCY
				end
				PART.AncestryChanged:connect(function()
					PART.Parent = PARENT
				end)
			end
		end
	end
	function immortality()
		for e = 1, #immortal do
			if immortal[e] ~= nil then
				local STUFF = immortal[e]
				local PART = STUFF[1]
				local PARENT = STUFF[2]
				local MATERIAL = STUFF[3]
				local COLOR = STUFF[4]
				local TRANSPARENCY = STUFF[5]
				if PART.ClassName == "Part" and PART == Root then
					PART.Material = MATERIAL
					PART.Color = COLOR
					PART.Transparency = TRANSPARENCY
				end
				if PART.Parent ~= PARENT then
					hum:Remove()
					PART.Parent = PARENT
					hum = Instance.new("Humanoid",Character)
					hum.Name = "noneofurbusiness"
				end
			end
		end
	end
	coroutine.wrap(function()
		while true do
			if hum.Health < .1 then
				deadsound = Instance.new("Sound", Torso)
				deadsound.Volume = 6
				deadsound.SoundId = "rbxassetid://1411352723"
				deadsound:Play()
				immortality()
			end
			wait()
		end
	end)()

	local anims = coroutine.wrap(function()
		while true do
			settime = 0.05
			sine = sine + change
			if position == "Jump" and attacking == false then
				change = 1
				spin = false
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
				RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
				LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.2)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.2)
			elseif position == "Falling" and attacking == false then
				change = 1
				spin = false
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(0)), 0.15)
				LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
				RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
				LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(-4), math.rad(0)), 0.2)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(45)), 0.2)
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(-45)), 0.2)
			elseif position == "Walking" and attacking == false and running == false then
				change = 1.2
				walking = true
				spin = false
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5 + Root.RotVelocity.Y / 85,.35,-.5*math.sin(sine/11)) * CFrame.Angles(math.rad(35*math.sin(sine/11)),math.rad(0*math.sin(sine/11)),math.rad(-10 + Root.RotVelocity.Y / 10, math.sin(-20 * math.sin(sine/4)))),.3)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5 + Root.RotVelocity.Y / 85,.45,.5*math.sin(sine/11)) * CFrame.Angles(math.rad(-55*math.sin(sine/11)),math.rad(-5*math.sin(sine/8)),math.rad(10 + Root.RotVelocity.Y / 10, math.sin(20 * math.sin(sine/4)))),.3)
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.15 * 0.6*-math.sin(sine/5.5), 0) * CFrame.Angles(math.rad(10), math.rad(12 * -math.sin(sine/11)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.3)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/11)/2.8, -.2  + 0.2 - math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) + -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0), math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/11)/2.8, -.2 + 0.2 + math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) - -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0) , math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
			elseif position == "Idle" and attacking == false and running == false then
				change = .5
				spin = true
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)),math.rad(0),math.rad(0)),.1)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(10)), 0.1)
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(-10)), 0.1)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(-10)), 0.1)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(10)), 0.1)
			elseif position == "Running" and attacking == false then
				change = 1
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
				LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
				RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
				LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
			end
			swait()
		end
	end)
	anims()
end)

Kekw.Name = "Kekw"
Kekw.Parent = Frame
Kekw.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Kekw.Position = UDim2.new(0.123673894, 0, 0.724017024, 0)
Kekw.Size = UDim2.new(0, 106, 0, 44)
Kekw.Font = Enum.Font.SourceSans
Kekw.Text = "Killbot v3"
Kekw.TextColor3 = Color3.fromRGB(0, 0, 0)
Kekw.TextSize = 20.000
Kekw.MouseButton1Down:connect(function()
	--//====================================================\\--
	--||			   CREATED BY SHACKLUSTER
	--\\====================================================//--

	wait(0.2)

	Player = game:GetService("Players").LocalPlayer
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character
	Humanoid = Character.Humanoid
	Mouse = Player:GetMouse()
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Head = Character["Head"]
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor

	--//=================================\\
	--|| 	      USEFUL VALUES
	--\\=================================//

	Animation_Speed = 3
	Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
	local Speed = 16
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local DAMAGEMULTIPLIER = 1
	local ANIM = "Idle"
	local ATTACK = false
	local EQUIPPED = false
	local HOLD = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local KEYHOLD = false
	local CHANGE = 2 / Animation_Speed
	local WALKINGANIM = false
	local VALUE1 = false
	local VALUE2 = false
	local ROBLOXIDLEANIMATION = IT("Animation")
	ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
	ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
	--ROBLOXIDLEANIMATION.Parent = Humanoid
	local WEAPONGUI = IT("ScreenGui", PlayerGui)
	WEAPONGUI.Name = "Weapon GUI"
	local Weapon = IT("Model")
	Weapon.Name = "Adds"
	local Effects = IT("Folder", Weapon)
	Effects.Name = "Effects"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character.Animate
	local UNANCHOR = true

	--//=================================\\
	--\\=================================//


	--//=================================\\
	--|| SAZERENOS' ARTIFICIAL HEARTBEAT
	--\\=================================//

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	--//=================================\\
	--\\=================================//

	--//=================================\\
	--|| 	      SOME FUNCTIONS
	--\\=================================//

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
		local frame = IT("Frame")
		frame.BackgroundTransparency = TRANSPARENCY
		frame.BorderSizePixel = BORDERSIZEPIXEL
		frame.Position = POSITION
		frame.Size = SIZE
		frame.BackgroundColor3 = COLOR
		frame.BorderColor3 = BORDERCOLOR
		frame.Name = NAME
		frame.Parent = PARENT
		return frame
	end

	function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
		local label = IT("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UD2(1, 0, 1, 0)
		label.Position = UD2(0, 0, 0, 0)
		label.TextColor3 = TEXTCOLOR
		label.TextStrokeTransparency = STROKETRANSPARENCY
		label.TextTransparency = TRANSPARENCY
		label.FontSize = TEXTFONTSIZE
		label.Font = TEXTFONT
		label.BorderSizePixel = BORDERSIZEPIXEL
		label.TextScaled = false
		label.Text = TEXT
		label.Name = NAME
		label.Parent = PARENT
		return label
	end

	function NoOutlines(PART)
		PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
	end

	function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
		local NEWWELD = IT(TYPE)
		NEWWELD.Part0 = PART0
		NEWWELD.Part1 = PART1
		NEWWELD.C0 = C0
		NEWWELD.C1 = C1
		NEWWELD.Parent = PARENT
		return NEWWELD
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end

	--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	function WACKYEFFECT(Table)
		local TYPE = (Table.EffectType or "Sphere")
		local SIZE = (Table.Size or VT(1,1,1))
		local ENDSIZE = (Table.Size2 or VT(0,0,0))
		local TRANSPARENCY = (Table.Transparency or 0)
		local ENDTRANSPARENCY = (Table.Transparency2 or 1)
		local CFRAME = (Table.CFrame or Torso.CFrame)
		local MOVEDIRECTION = (Table.MoveToPos or nil)
		local ROTATION1 = (Table.RotationX or 0)
		local ROTATION2 = (Table.RotationY or 0)
		local ROTATION3 = (Table.RotationZ or 0)
		local MATERIAL = (Table.Material or "Neon")
		local COLOR = (Table.Color or C3(1,1,1))
		local TIME = (Table.Time or 45)
		local SOUNDID = (Table.SoundID or nil)
		local SOUNDPITCH = (Table.SoundPitch or nil)
		local SOUNDVOLUME = (Table.SoundVolume or nil)
		coroutine.resume(coroutine.create(function()
			local PLAYSSOUND = false
			local SOUND = nil
			local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
			if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
				PLAYSSOUND = true
				SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
			end
			EFFECT.Color = COLOR
			local MSH = nil
			if TYPE == "Sphere" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
			elseif TYPE == "Block" then
				MSH = IT("BlockMesh",EFFECT)
				MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
			elseif TYPE == "Wave" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
			elseif TYPE == "Ring" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
			elseif TYPE == "Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Round Slash" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
			elseif TYPE == "Swirl" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
			elseif TYPE == "Skull" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
			elseif TYPE == "Crystal" then
				MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
			end
			if MSH ~= nil then
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH = SIZE - ENDSIZE
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = CFRAME
				end
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.X/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until SOUND.Playing == false
					EFFECT:remove()
				end
			else
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat Swait() until SOUND.Playing == false
					EFFECT:remove()
				end
			end
		end))
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end

	function CharacterFade(COLOR,TIMER)
		coroutine.resume(coroutine.create(function()
			local FADE = IT("Model",Effects)
			for _, c in pairs(Character:GetChildren()) do
				if c.ClassName == "Part" and c ~= RootPart then
					local FADER = c:Clone()
					FADER.Color = COLOR
					FADER.CFrame = c.CFrame
					FADER.Parent = FADE
					FADER.Anchored = true
					FADER.Transparency = 0.25
					FADER:BreakJoints()
					FADER.Material = "Glass"
					FADER:ClearAllChildren()
					if FADER.Name == "Head" then
						FADER.Size = VT(1,1,1)
					end
				end
			end
			local TRANS = 0.75/TIMER
			for i = 1, TIMER do
				Swait()
				for _, c in pairs(FADE:GetChildren()) do
					if c.ClassName == "Part" then
						c.Transparency = c.Transparency + TRANS
					end
				end
			end
			FADE:remove()
		end))
	end

	local PE=Instance.new("ParticleEmitter")
	PE.LightEmission=0.3
	PE.Size=NumberSequence.new(0)
	PE.Transparency=NumberSequence.new(0,1)
	PE.Rotation=NumberRange.new(0,360)
	PE.LockedToPart = false
	PE.Speed = NumberRange.new(0,0,0)
	PE.ZOffset = 0.3
	PE.Rate = 999
	PE.VelocitySpread = 25
	PE.Name = "Particles"

	function CreateParticles(art,accel,drag,lifetime,type,isenabledbydefault,locked,size,speed)
		local particle = nil
		coroutine.resume(coroutine.create(function(PART)
			particle = PE:Clone()
			Swait()
			particle.Rate = 999
			particle.Parent = art
			particle.Acceleration = accel
			if type == "Fire" then
				local EyeSizes={
					NumberSequenceKeypoint.new(0,size,size/2),
					NumberSequenceKeypoint.new(1,size/4,size/8)
				}
				particle.Size = NumberSequence.new(EyeSizes)
			elseif type == "Smoke" then
				local EyeSizes={
					NumberSequenceKeypoint.new(0,size/5,0),
					NumberSequenceKeypoint.new(1,size*2,0.5)
				}
				particle.Size = NumberSequence.new(EyeSizes)
			elseif type == "Solid" then
				local EyeSizes={
					NumberSequenceKeypoint.new(0,size,0),
					NumberSequenceKeypoint.new(1,size,0)
				}
				particle.Size = NumberSequence.new(EyeSizes)
			end
			particle.Lifetime=NumberRange.new(lifetime)
			particle.Drag = drag
			if locked == true then
				particle.LockedToPart = true
			end
			particle.Speed = NumberRange.new(speed*0.8,speed)
			particle.Texture = "http://www.roblox.com/asset/?id=1179557490"
			particle.Enabled = isenabledbydefault
			particle.Color = ColorSequence.new(Color3.new(255/255, 176/255, 0))
		end))
		return particle
	end

	--//=================================\\
	--||	     RAGDOLL STUFF
	--\\=================================//

	function recurse(root,callback,i)
		i= i or 0
		for _,v in pairs(root:GetChildren()) do
			i = i + 1
			callback(i,v)

			if #v:GetChildren() > 0 then
				i = recurse(v,callback,i)
			end
		end

		return i
	end

	function ragdollJoint(character, part0, part1, attachmentName, className, properties)
		attachmentName = attachmentName.."RigAttachment"
		local constraint = Instance.new(className.."Constraint")
		constraint.Attachment0 = part0:FindFirstChild(attachmentName)
		constraint.Attachment1 = part1:FindFirstChild(attachmentName)
		constraint.Name = "RagdollConstraint"..part1.Name

		for _,propertyData in next,properties or {} do
			constraint[propertyData[1]] = propertyData[2]
		end

		constraint.Parent = character
	end

	function getAttachment0(character, attachmentName)
		for _,child in next,character:GetChildren() do
			local attachment = child:FindFirstChild(attachmentName)
			if attachment then
				return attachment
			end
		end
	end

	function ArtificialHitbox(Part)
		local HITBOX = CreatePart(3, Part, "Metal", 0, 1, "Really black", "Hitbox", Part.Size/2, false)
		HITBOX.CanCollide = true
		HITBOX.CFrame = Part.CFrame
		weldBetween(Part,HITBOX)
	end

	function R15Ragdoll(character,KeepArms)
		character:BreakJoints()
		coroutine.resume(coroutine.create(function()
			recurse(character, function(_,v)
				if v:IsA("Attachment") then
					v.Axis = Vector3.new(0, 1, 0)
					v.SecondaryAxis = Vector3.new(0, 0, 1)
					v.Rotation = Vector3.new(0, 0, 0)
				end
			end)
			for _,child in next,character:GetChildren() do
				if child:IsA("Accoutrement") then
					for _,part in next,child:GetChildren() do
						if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
							local attachment1 = part:FindFirstChildOfClass("Attachment")
							local attachment0 = getAttachment0(character,attachment1.Name)
							if attachment0 and attachment1 then
								local constraint = Instance.new("HingeConstraint")
								constraint.Attachment0 = attachment0
								constraint.Attachment1 = attachment1
								constraint.LimitsEnabled = true
								constraint.UpperAngle = 0
								constraint.LowerAngle = 0
								constraint.Parent = character
							end
							ArtificialHitbox(part)
						elseif part.Name == "HumanoidRootPart" then
							part:remove()
						end
					end
				end
			end

			ragdollJoint(character,character.LowerTorso, character.UpperTorso, "Waist", "BallSocket", {
				{"LimitsEnabled",true};
				{"UpperAngle",5};
			})
			if character:FindFirstChild("Head") then
				ragdollJoint(character,character.UpperTorso, character.Head, "Neck", "BallSocket", {
					{"LimitsEnabled",true};
					{"UpperAngle",15};
				})
			end

			local handProperties = {
				{"LimitsEnabled", true};
				{"UpperAngle",0};
				{"LowerAngle",0};
			}
			ragdollJoint(character,character.LeftLowerArm, character.LeftHand, "LeftWrist", "Hinge", handProperties)
			ragdollJoint(character,character.RightLowerArm, character.RightHand, "RightWrist", "Hinge", handProperties)

			local shinProperties = {
				{"LimitsEnabled", true};
				{"UpperAngle", 0};
				{"LowerAngle", -75};
			}
			ragdollJoint(character,character.LeftUpperLeg, character.LeftLowerLeg, "LeftKnee", "Hinge", shinProperties)
			ragdollJoint(character,character.RightUpperLeg, character.RightLowerLeg, "RightKnee", "Hinge", shinProperties)

			local footProperties = {
				{"LimitsEnabled", true};
				{"UpperAngle", 15};
				{"LowerAngle", -45};
			}
			ragdollJoint(character,character.LeftLowerLeg, character.LeftFoot, "LeftAnkle", "Hinge", footProperties)
			ragdollJoint(character,character.RightLowerLeg, character.RightFoot, "RightAnkle", "Hinge", footProperties)
			if KeepArms == true then
				ragdollJoint(character,character.UpperTorso, character.RightUpperArm, "RightShoulder", "BallSocket")
				ragdollJoint(character,character.RightUpperArm, character.RightLowerArm, "RightElbow", "BallSocket")
				ragdollJoint(character,character.UpperTorso, character.LeftUpperArm, "LeftShoulder", "BallSocket")
				ragdollJoint(character,character.LeftUpperArm, character.LeftLowerArm, "LeftElbow", "BallSocket")
			end
			ragdollJoint(character,character.LowerTorso, character.LeftUpperLeg, "LeftHip", "BallSocket")
			ragdollJoint(character,character.LowerTorso, character.RightUpperLeg, "RightHip", "BallSocket")
			Debris:AddItem(character,5)
		end))
	end

	function Ragdoll(Character2,CharTorso,KeepArms)
		coroutine.resume(coroutine.create(function()
			Character2:BreakJoints()
			local hum = Character2:findFirstChild("Humanoid")
			hum:remove()
			local function Scan(ch)
				local e
				for e = 1,#ch do
					Scan(ch[e]:GetChildren())
					if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
						ch[e]:remove()
					end
				end
			end
			local NEWHUM = IT("Humanoid")
			NEWHUM.Name = "Corpse"
			NEWHUM.Health = 0
			NEWHUM.MaxHealth = 0
			NEWHUM.PlatformStand = true
			NEWHUM.Parent = Character2
			NEWHUM.DisplayDistanceType = "None"

			local ch = Character2:GetChildren()
			local i
			for i = 1,#ch do
				if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
					ch[i]:remove()
				end
			end

			local Torso2 = Character2.Torso
			local movevector = Vector3.new()

			if Torso2 then
				movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
				local Head = Character2:FindFirstChild("Head")
				if Head then
					local Neck = Instance.new("Weld")
					Neck.Name = "Neck"
					Neck.Part0 = Torso2
					Neck.Part1 = Head
					Neck.C0 = CFrame.new(0, 1.5, 0)
					Neck.C1 = CFrame.new()
					Neck.Parent = Torso2

				end
				local Limb = Character2:FindFirstChild("Right Arm")
				if Limb and KeepArms == true then

					Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
					local Joint = Instance.new("Glue")
					Joint.Name = "RightShoulder"
					Joint.Part0 = Torso2
					Joint.Part1 = Limb
					Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					Joint.Parent = Torso2

					local B = Instance.new("Part")
					B.TopSurface = 0
					B.BottomSurface = 0
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1
					B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = Character2
					local W = Instance.new("Weld")
					W.Part0 = Limb
					W.Part1 = B
					W.C0 = CFrame.new(0, -0.5, 0)
					W.Parent = Limb

				end
				local Limb = Character2:FindFirstChild("Left Arm")
				if Limb and KeepArms == true then

					Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
					local Joint = Instance.new("Glue")
					Joint.Name = "LeftShoulder"
					Joint.Part0 = Torso2
					Joint.Part1 = Limb
					Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					Joint.Parent = Torso2

					local B = Instance.new("Part")
					B.TopSurface = 0
					B.BottomSurface = 0
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1
					B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = Character2
					local W = Instance.new("Weld")
					W.Part0 = Limb
					W.Part1 = B
					W.C0 = CFrame.new(0, -0.5, 0)
					W.Parent = Limb

				end
				local Limb = Character2:FindFirstChild("Right Leg")
				if Limb then

					Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
					local Joint = Instance.new("Glue")
					Joint.Name = "RightHip"
					Joint.Part0 = Torso2
					Joint.Part1 = Limb
					Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					Joint.Parent = Torso2

					local B = Instance.new("Part")
					B.TopSurface = 0
					B.BottomSurface = 0
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1
					B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = Character2
					local W = Instance.new("Weld")
					W.Part0 = Limb
					W.Part1 = B
					W.C0 = CFrame.new(0, -0.5, 0)
					W.Parent = Limb

				end
				local Limb = Character2:FindFirstChild("Left Leg")
				if Limb then

					Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
					local Joint = Instance.new("Glue")
					Joint.Name = "LeftHip"
					Joint.Part0 = Torso2
					Joint.Part1 = Limb
					Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					Joint.Parent = Torso2

					local B = Instance.new("Part")
					B.TopSurface = 0
					B.BottomSurface = 0
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1
					B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = Character2
					local W = Instance.new("Weld")
					W.Part0 = Limb
					W.Part1 = B
					W.C0 = CFrame.new(0, -0.5, 0)
					W.Parent = Limb

				end
				--[
				local Bar = Instance.new("Part")
				Bar.TopSurface = 0
				Bar.BottomSurface = 0
				Bar.formFactor = "Symmetric"
				Bar.Size = Vector3.new(1, 1, 1)
				Bar.Transparency = 1
				Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
				Bar.Parent = Character2
				local Weld = Instance.new("Weld")
				Weld.Part0 = Torso2
				Weld.Part1 = Bar
				Weld.C0 = CFrame.new(0, 0.5, 0)
				Weld.Parent = Torso2
				--]]
			end
			Character2.Parent = workspace
			Debris:AddItem(Character2,5)

			return Character2,Torso2
		end))
	end

	--//=================================\\
	--||	     WEAPON CREATION
	--\\=================================//

	local DUST = CreateParticles(RightArm,VT(0,0,0),5,2,"Smoke",false,false,5,0)
	DUST.ZOffset = 1
	RightArm.Transparency = 1
	local BasePart = CreatePart(3, Weapon, "Metal", 0, 0, "Really black", "Part", VT(1,2,1),false)
	CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, BasePart, CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Sphere = CreatePart(3, Weapon, "Metal", 0, 0, "Really black", "Part", VT(1.4,1.4,1.4),false)
	MakeForm(Sphere,"Ball")
	CreateWeldOrSnapOrMotor("Weld", BasePart, BasePart, Sphere, CF(0.2,0.8,0.1) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local LaserPart = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(0.3,0.3,0.1),false)
	MakeForm(LaserPart,"Ball")
	CreateWeldOrSnapOrMotor("Weld", Sphere, Sphere, LaserPart, CF(0,0,-0.65) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Bump = CreatePart(3, Weapon, "Metal", 0, 0, "Really black", "Part", VT(0.3,0.3,0.2),false)
	MakeForm(Bump,"Ball")
	CreateWeldOrSnapOrMotor("Weld", Sphere, Sphere, Bump, CF(0,0,0.65) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local BottomLaser = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(0.4,0,0.4),false)
	MakeForm(BottomLaser,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", BasePart, BasePart, BottomLaser, CF(0,-1,0) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part1 = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(0,0.5,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", BasePart, BasePart, Part1, CF(0,-0.76,-0.26) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part2 = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(0,0.5,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", BasePart, Part1, Part2, CF(0,0.25,0) * ANGLES(RAD(0), RAD(0), RAD(-25)), CF(0, -0.25, 0))
	local Part3 = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(0,0.5,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", BasePart, Part1, Part3, CF(0,0.25,0) * ANGLES(RAD(0), RAD(0), RAD(-90)), CF(0, -0.26, 0))
	local Part4 = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(0,0.56,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", BasePart, Part2, Part4, CF(0,0.25,0) * ANGLES(RAD(0), RAD(0), RAD(90)), CF(0, -0.26, 0))
	local Part5 = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(0,0.56,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", BasePart, Part4, Part5, CF(0,0.25,0) * ANGLES(RAD(0), RAD(0), RAD(-125)), CF(0, -0.26, 0))
	local Part = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(0,0.25,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", BasePart, Part4, Part, CF(0,0.25,0) * ANGLES(RAD(0), RAD(0), RAD(25)), CF(0, -0.26/2, 0))
	local Part = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(0,0.3,0.5),false)
	CreateWeldOrSnapOrMotor("Weld", BasePart, Part2, Part, CF(0,0.25,0) * ANGLES(RAD(0), RAD(0), RAD(-65)), CF(0, -0.31/2, 0))
	local Part = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(1.4,0,1.4),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Sphere, Sphere, Part, CF(0.035,0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local Part = CreatePart(3, Weapon, "Neon", 0, 0, "Really red", "Part", VT(1.4,0,1.4),false)
	MakeForm(Part,"Cyl")
	CreateWeldOrSnapOrMotor("Weld", Sphere, Sphere, Part, CF(0,-0.035,0) * ANGLES(RAD(0), RAD(0), RAD(90)), CF(0, 0, 0))
	local Sphere = CreatePart(3, Weapon, "Metal", 0, 0, "Really black", "Part", VT(0.3,1.6,0.7),false)
	MakeForm(Sphere,"Ball")
	CreateWeldOrSnapOrMotor("Weld", BasePart, BasePart, Sphere, CF(0.45,0.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
	local BODY = {}
	for _, c in pairs(Character:GetDescendants()) do
		if c:IsA("BasePart") then
			table.insert(BODY, {
				c,
				c.Parent,
				c.Material,
				c.Color
			})
		elseif c:IsA("JointInstance") then
			table.insert(BODY, {
				c,
				c.Parent,
				nil,
				nil
			})
		end
	end
	for _, c in pairs(Weapon:GetChildren()) do
		if c.ClassName == "Part" then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
	end


	for _, c in pairs(Character:GetDescendants()) do
		if c:IsA("BasePart") then
			table.insert(BODY, {
				c,
				c.Parent,
				c.Material,
				c.Color
			})
		elseif c:IsA("JointInstance") then
			table.insert(BODY, {
				c,
				c.Parent,
				nil,
				nil
			})
		end
	end

	for e = 1, #BODY do
		if BODY[e] ~= nil then
			do
				local STUFF = BODY[e]
				local PART = STUFF[1]
				local PARENT = STUFF[2]
				local MATERIAL = STUFF[3]
				local COLOR = STUFF[4]
				PART.AncestryChanged:Connect(function()
					if PART.ClassName == "Part" then
						PART.Material = MATERIAL
						PART.Color = COLOR
					end
					PART.Parent = PARENT
				end)
			end
		end
	end
	function refit()
		Weapon.Parent = Character
		Character.Parent = workspace
		for e = 1, #BODY do
			if BODY[e] ~= nil then
				local STUFF = BODY[e]
				local PART = STUFF[1]
				local PARENT = STUFF[2]
				local MATERIAL = STUFF[3]
				local COLOR = STUFF[4]
				if PART.Parent ~= PARENT then
					Humanoid:remove()
					if PART.ClassName == "Part" then
						PART.Material = MATERIAL
						PART.Color = COLOR
					end
					PART.Parent = PARENT
					Humanoid = IT("Humanoid", Character)
				end
			end
		end
	end



	local SKILLTEXTCOLOR = C3(1,0,0)
	local SKILLFONT = "SciFi"
	local SKILLTEXTSIZE = 5

	Weapon.Parent = Character
	Humanoid.Died:connect(function()
		refit()
	end)


	local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
	local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.86, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
	local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.82, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
	local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.78, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
	local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.74, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
	local SKILL6FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.70, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 6 Frame")

	local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 1")
	local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 2")
	local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 3")
	local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 4")
	local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[E]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 5")
	local SKILL6TEXT = CreateLabel(SKILL6FRAME, "[X]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Text 6")

	--//=================================\\
	--||	ATTACK FUNCTIONS AND STUFF
	--\\=================================//

	function Warp()
		local HITFLOOR,HITPOS = Raycast(Mouse.Hit.p+VT(0,1,0), (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 100, Character)
		if HITFLOOR then
			CharacterFade(C3(0.5,0,0),50)
			HITPOS = HITPOS + VT(0,3.5,0)
			local POS = RootPart.Position
			RootPart.CFrame = CF(HITPOS,CF(POS,HITPOS)*CF(0,0,-100000).p)
			CreateSound(289556450,Torso,2,MRANDOM(8,13)/10,false)
		end
	end

	function Dash()
		ATTACK = true
		Rooted = true
		local SOUND = CreateSound(1165167610, Torso, 1, 1, true)
		local LOOP = 0
		repeat
			LOOP = LOOP + 1
			Swait()
			local RAY,RAYPOS = Raycast(RootPart.Position, (CF(RootPart.Position, Mouse.Hit.p)).lookVector, 5, workspace)	
			local HITFLOOR,HITPOS,NORMAL = Raycast(RAYPOS+VT(0,1,0), (CF(RAYPOS, RAYPOS + VT(0, -1, 0))).lookVector, 100, Character)
			if HITFLOOR then
				CharacterFade(C3(0.5,0,0),35)
				HITPOS = HITPOS + VT(0,3.5,0)
				local POS = RootPart.Position
				RootPart.CFrame = CF(HITPOS,CF(POS,HITPOS)*CF(0,0,-100000).p)
				RootPart.Velocity = VT(0,0,0)
				RootPart.RotVelocity = VT(0,0,0)
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(75), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-45), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-15), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-15), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		until KEYHOLD == false
		coroutine.resume(coroutine.create(function()
			for i = 1, 20 do
				Swait()
				SOUND.Volume = SOUND.Volume - 1/20
			end
			SOUND:remove()
		end))
		if LOOP > 50 then
			CreateSound(772085046,Torso,5,MRANDOM(8,13)/10,false)
			for i = 1, 100 do
				Swait()
				RootPart.CFrame = RootPart.CFrame * CF(0,0,-(1-(i/100))/3)
				WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1,0.5,1), Size2 = VT(2,0,2), Transparency = 0.7, Transparency2 = 1, CFrame = CF(RightLeg.CFrame*CF(0,-1,0).p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0.3,0.3,0.3), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(1,0.5,1), Size2 = VT(2,0,2), Transparency = 0.7, Transparency2 = 1, CFrame = CF(LeftLeg.CFrame*CF(0,-1,0).p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0.3,0.3,0.3), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		end
		ATTACK = false
		Rooted = false
	end

	function LimbRip()
		ATTACK = true
		Rooted = false
		local TARGET = nil
		local ROOT = nil
		local HUMAN = nil
		local DIST = 4
		Speed = 12
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			local CHILDREN = workspace:GetDescendants()
			for index, CHILD in pairs(CHILDREN) do
				if CHILD.ClassName == "Model" and CHILD ~= Character then
					local HUM = CHILD:FindFirstChildOfClass("Humanoid")
					if HUM then
						local TORSO = CHILD:FindFirstChild("HumanoidRootPart") or CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
						if TORSO and HUM.Health > 0 then
							if (TORSO.Position - RightArm.Position).Magnitude <= DIST then
								DIST = (TORSO.Position - RightArm.Position).Magnitude
								ROOT = TORSO
								HUMAN = HUM
								TARGET = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							end
						end
					end
				end
			end
			if ROOT then
				break
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(-25)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -0.4) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-25), RAD(0), RAD(15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 16
		if ROOT then
			CreateSound(305685800,Torso,5,1.3,false)
			Rooted = true
			local GORED = false
			coroutine.resume(coroutine.create(function()
				repeat
					Swait()
					ROOT.Anchored = true
				until GORED == true
				ROOT.Anchored = false
			end))
			RootPart.CFrame = ROOT.CFrame*CF(0,0,2.25)
			if TARGET.Name == "Torso" then
				local RARM = TARGET.Parent:FindFirstChild("Right Arm")
				local LARM = TARGET.Parent:FindFirstChild("Left Arm")
				if RARM and LARM then
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(90), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for _, c in pairs(TARGET.Parent:GetDescendants()) do
						if c:IsA("JointInstance") then
							if c.Part1 == RARM or c.Part1 == LARM or c.Part0 == RARM or c.Part0 == LARM then
								c:remove()
							end
						end
					end
					CreateSound(363808674, TARGET, 3, MRANDOM(7,9)/10, false)
					CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, RARM, CF(0,-1.35,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
					CreateWeldOrSnapOrMotor("Weld", LeftArm, LeftArm, LARM, CF(0,-1.35,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.25) * ANGLES(RAD(-25), RAD(0), RAD(80)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,1.5,0), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i=0, 0.1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.2, 0.25) * ANGLES(RAD(-35), RAD(0), RAD(80)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,-0.3,0), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					GORED = true
					Ragdoll(TARGET.Parent,Torso)
					if ROOT.Name ~= "Torso" then
						ROOT:remove()
					end
					local RGRAB = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, RARM, CF(0,-1.35,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
					local LGRAB = CreateWeldOrSnapOrMotor("Weld", LeftArm, LeftArm, LARM, CF(0,-1.35,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
					local bv = Instance.new("BodyVelocity",TARGET) 
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = TARGET.CFrame.lookVector*75
					Debris:AddItem(bv,0.05)
					CreateSound(621557962, RightLeg, 1, MRANDOM(7,9)/10, false)
					for i=0, 0.5, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.2, 0.25) * ANGLES(RAD(-35), RAD(0), RAD(80)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(160), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,-0.3,0), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(0), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 0.6 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local HITBOX = CreatePart(3, RARM, "Metal", 0, 1, "Really black", "Part", RARM.Size, false)
					HITBOX.CFrame = RARM.CFrame
					HITBOX.CanCollide = true
					weldBetween(RARM,HITBOX)
					local HITBOX = CreatePart(3, LARM, "Metal", 0, 1, "Really black", "Part", RARM.Size, false)
					HITBOX.CFrame = LARM.CFrame
					HITBOX.CanCollide = true
					weldBetween(LARM,HITBOX)
					RGRAB:remove()
					LGRAB:remove()
					for i=0, 0.4, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.4) * ANGLES(RAD(0), RAD(0), RAD(110)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(0), RAD(0), RAD(-110)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
				end
			elseif TARGET.Name == "UpperTorso" then
				if TARGET.Parent:FindFirstChild("RightUpperArm") and TARGET.Parent:FindFirstChild("LeftUpperArm") then
					for i=0, 0.3, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, -0.5) * ANGLES(RAD(140), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local SAWBLADE = CreatePart(3, Weapon, "Neon", 0, 0.5, "Really red", "Part", VT(0,0,0),false)
					local WELD = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, SAWBLADE, CF(0,-1,0) * ANGLES(RAD(0), RAD(90), RAD(0)), CF(0, 0, 0))
					local BLADE = true
					CreateMesh("SpecialMesh", SAWBLADE, "FileMesh", "74322089", "", VT(1,1,1), VT(0,0,0))
					coroutine.resume(coroutine.create(function()
						repeat
							Swait()
							WELD.C1 = WELD.C1 * ANGLES(RAD(0), RAD(0), RAD(25))
						until BLADE == false
						SAWBLADE:remove()
					end))
					CreateSound(1165167936, SAWBLADE, 2, 1, true)
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, -0.5) * ANGLES(RAD(140), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(25), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i=0, 3, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, -0.5) * ANGLES(RAD(15), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * RIGHTSHOULDERC0, 0.1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					CreateSound(363808674, TARGET, 3, MRANDOM(7,9)/10, false)
					TARGET.Parent:FindFirstChild("RightUpperArm").RightShoulder:remove()
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(1, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(90)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-80)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, 0) * ANGLES(RAD(140), RAD(0), RAD(90)) * ANGLES(RAD(0), RAD(45), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i=0, 3, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(1, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-80)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * ANGLES(RAD(0), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, 0.1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					CreateSound(363808674, TARGET, 3, MRANDOM(7,9)/10, false)
					TARGET.Parent:FindFirstChild("LeftUpperArm").LeftShoulder:remove()
					BLADE = false
					for i=0, 0.5, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.25) * ANGLES(RAD(-25), RAD(0), RAD(80)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-25), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,1.5,0), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i=0, 0.1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.2, 0.25) * ANGLES(RAD(-35), RAD(0), RAD(80)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-32), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,-0.3,0), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					GORED = true
					TARGET.Parent:BreakJoints()
					R15Ragdoll(TARGET.Parent)
					if ROOT.Name ~= "Torso" then
						ROOT:remove()
					end
					local bv = Instance.new("BodyVelocity",TARGET) 
					bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
					bv.velocity = TARGET.CFrame.lookVector*75
					Debris:AddItem(bv,0.05)
					CreateSound(621557962, RightLeg, 1, MRANDOM(7,9)/10, false)
					for i=0, 0.3, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.2, 0.25) * ANGLES(RAD(-35), RAD(0), RAD(80)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-30)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-32), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-65), RAD(0), RAD(0)) * CF(0,-0.3,0), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
				end
			end
		end
		ATTACK = false
		Rooted = false
	end

	function Buzzsaw()
		ATTACK = true
		Rooted = false
		local ARMSPEED = 0.1
		local TARGET = nil
		local ROOT = nil
		local HUMAN = nil
		local DIST = 4
		local SAWBLADE = CreatePart(3, Weapon, "Neon", 0, 0.5, "Really red", "Part", VT(0,0,0),false)
		local WELD = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, SAWBLADE, CF(0,-1,0) * ANGLES(RAD(0), RAD(90), RAD(0)), CF(0, 0, 0))
		local BLADE = true
		CreateMesh("SpecialMesh", SAWBLADE, "FileMesh", "74322089", "", VT(2,2,1), VT(0,0,0))
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				WELD.C1 = WELD.C1 * ANGLES(RAD(0), RAD(0), RAD(25))
			until BLADE == false
			SAWBLADE:remove()
		end))
		CreateSound(1165167936, SAWBLADE, 2, 1, true)
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, -0.5) * ANGLES(RAD(175), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 2, 0.1 / Animation_Speed do
			Swait()
			local CHILDREN = workspace:GetDescendants()
			for index, CHILD in pairs(CHILDREN) do
				if CHILD.ClassName == "Model" and CHILD ~= Character then
					local HUM = CHILD:FindFirstChildOfClass("Humanoid")
					if HUM then
						local TORSO = CHILD:FindFirstChild("HumanoidRootPart") or CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
						if TORSO and HUM.Health > 0 then
							if (TORSO.Position - RightArm.Position).Magnitude <= DIST then
								DIST = (TORSO.Position - RightArm.Position).Magnitude
								ROOT = TORSO
								HUMAN = HUM
								TARGET = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
							end
						end
					end
				end
			end
			if ROOT then
				break
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, -0.5) * ANGLES(RAD(15), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, ARMSPEED / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		if ROOT then
			ARMSPEED = 0.03
			Rooted = true
			RootPart.CFrame = ROOT.CFrame*CF(0,0,2.5)
			repeat
				HUMAN.Health = HUMAN.Health - 0.5
				Swait()
				ROOT.Anchored = true
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(1, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0, 0) * ANGLES(RAD(15), RAD(0), RAD(45)) * ANGLES(RAD(0), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, ARMSPEED / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			until RightArm.Position.Y < Torso.Position.Y-0.15 or HUMAN.Health == 0
			ROOT.Anchored = false
			if HUMAN.Health == 0 then
				if ROOT.Name ~= "Torso" then
					ROOT:remove()
				end
				if TARGET.Name == "Torso" then
					Ragdoll(HUMAN.Parent,Torso,true)
				elseif TARGET.Name == "UpperTorso" then
					R15Ragdoll(HUMAN.Parent,true)
				end
			end
		end
		BLADE = false
		ATTACK = false
		Rooted = false
	end

	function ReeeEEEEEE()
		ATTACK = true
		Rooted = false
		Speed = 12
		local FX = CreateSound(198165368, Head, 4, 0.5, false)
		repeat
			Swait()
			FX.Parent = Head
			local CHILDREN = workspace:GetDescendants()
			for index, CHILD in pairs(CHILDREN) do
				if CHILD.ClassName == "Model" and CHILD ~= Character then
					local HUM = CHILD:FindFirstChildOfClass("Humanoid")
					if HUM then
						local TORSO = CHILD:FindFirstChild("Head")
						if TORSO then
							if (TORSO.Position - Head.Position).Magnitude <= 25 then
								WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = CF(TORSO.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								TORSO:remove()
								if CHILD:FindFirstChild("Torso") then
									Ragdoll(CHILD,Torso,true)
								elseif CHILD:FindFirstChild("UpperTorso") then
									R15Ragdoll(CHILD,true)
								end
							end
						end
					end
				end
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-45), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(15)) * ANGLES(RAD(0), RAD(15), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(-15), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-45), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-45), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		until FX.Playing == false
		Speed = 16
		ATTACK = false
		Rooted = false
	end

	function Needle()
		ATTACK = true
		Rooted = true
		local GYRO = IT("BodyGyro",RootPart)
		GYRO.D = 2
		GYRO.P = 2000
		GYRO.MaxTorque = VT(0,4000000,0)
		local NEEDGYRO = true
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				GYRO.CFrame = CF(RootPart.Position,Mouse.Hit.p)
			until NEEDGYRO == false
			GYRO:Remove()
		end))
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -1) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, -0.5) * ANGLES(RAD(25), RAD(0), RAD(80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, 0, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1.5, 0) * ANGLES(RAD(-90), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -1) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(15), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, -0.5) * ANGLES(RAD(25), RAD(0), RAD(80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, 0, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1.5, 0) * ANGLES(RAD(-90), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(RightArm.CFrame*CF(0,-1,0).p,Mouse.Hit.p,300,Character)
		WACKYEFFECT({Time = 45, EffectType = "Wave", Size = VT(1,0,1), Size2 = VT(5,1,5), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0) * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 90655239, SoundPitch = 1, SoundVolume = 2})
		NEEDGYRO = false
		if HIT then
			local NEEDLE = IT("Model",Effects)
			local BASE = CreatePart(3, NEEDLE, "Glass", 0, 0.5, "Pearl", "Part", VT(0.3,0.6,0.3), false)
			MakeForm(BASE,"Cyl")
			BASE.CFrame = CF(POS,RightArm.CFrame*CF(0,-1,0).p) * ANGLES(RAD(90), RAD(0), RAD(0))*CF(0,-0.35,0)
			weldBetween(BASE,HIT)
			local FLUID = CreatePart(3, NEEDLE, "Neon", 0, 0, "Lime green", "Part", VT(0.28,0.58,0.28), false)
			MakeForm(FLUID,"Cyl")
			FLUID.CFrame = BASE.CFrame
			weldBetween(BASE,FLUID)
			local PART = CreatePart(3, NEEDLE, "Metal", 0, 0, "Pearl", "Part", VT(0,0.2,0), false)
			PART.CFrame = BASE.CFrame*CF(0,0.4,0)
			weldBetween(BASE,PART)
			local PART = CreatePart(3, NEEDLE, "Metal", 0, 0, "Pearl", "Part", VT(0.1,0.1,0.1), false)
			PART.CFrame = BASE.CFrame*CF(0,-0.35,0)
			weldBetween(BASE,PART)
			local PART = CreatePart(3, NEEDLE, "Metal", 0, 0, "Pearl", "Part", VT(0.2,0.1,0.2), false)
			PART.CFrame = BASE.CFrame*CF(0,-0.4,0)
			weldBetween(BASE,PART)
			Debris:AddItem(NEEDLE,7)
			if HIT.Parent:FindFirstChildOfClass("Humanoid") then
				local HUMAN = HIT.Parent:FindFirstChildOfClass("Humanoid")
				coroutine.resume(coroutine.create(function()
					for i = 1, 500 do
						HUMAN.Health = HUMAN.Health - MRANDOM(1,6)/5
						if HUMAN.Health == 0 then
							break
						end
						Swait(2)
					end
					if HUMAN.Health == 0 then
						local CHILD = HUMAN.Parent
						if CHILD:FindFirstChild("Torso") then
							CHILD:FindFirstChild("Torso").CFrame = CHILD:FindFirstChild("Torso").CFrame * ANGLES(RAD(2), RAD(0), RAD(0))
							Ragdoll(CHILD,Torso,true)
						elseif CHILD:FindFirstChild("UpperTorso") then
							R15Ragdoll(CHILD,true)
						end
					end
				end))
			end
		end
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -1) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(15), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, -0.5) * ANGLES(RAD(25), RAD(0), RAD(80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, 0, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1.5, 0) * ANGLES(RAD(-90), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		ATTACK = false
		Rooted = false
	end

	function ScrewThis()
		ATTACK = true
		Rooted = true
		local SCREW = CreatePart(3, Weapon, "Neon", 0, 1, "Really red", "Part", VT(2, 0.4, 0.4)/2,false)
		SCREW.CanCollide = true
		local WELD = CreateWeldOrSnapOrMotor("Weld", LeftArm, LeftArm, SCREW, CF(0,-1,0.2) * ANGLES(RAD(0), RAD(90), RAD(0)), CF(0, 0, 0))
		CreateMesh("SpecialMesh", SCREW, "FileMesh", "70265804", "70265794", VT(1,1,1)/1.5, VT(0,0,0))
		for i=0, 0.4, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(0), RAD(15)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		SCREW.Transparency = 0
		for i=0, 0.1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-25)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(60), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-25)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.15, -0.5) * ANGLES(RAD(40), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, -0.3) * ANGLES(RAD(120), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(15), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i = 1, 3 do
			for i=0, 0.3, 0.1 / Animation_Speed do
				Swait()
				WELD.C1 = WELD.C1 * ANGLES(RAD(5), RAD(0), RAD(0))
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-25)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.15, -0.5) * ANGLES(RAD(40), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, -0.3) * ANGLES(RAD(120), RAD(0), RAD(78)) * ANGLES(RAD(0), RAD(15), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i=0, 1, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-25)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.15, -0.5) * ANGLES(RAD(40), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, -0.3) * ANGLES(RAD(120), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(15), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		end
		if MRANDOM(1, 5) == 1 then
			DUST:Emit(25)
			WELD:remove()
			CreateSound(328460122, RightArm, 3, 1, false)
			SCREW.Velocity = CF(RightArm.Position,SCREW.Position).lookVector*65
			Debris:AddItem(SCREW,6)
			for i=0, 3, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-25)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.15, -0.5) * ANGLES(RAD(40), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, -0.3) * ANGLES(RAD(120), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(15), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			for i = 1, 3 do
				for i=0, 0.35, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.15, -0.5) * ANGLES(RAD(40), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, -0.3) * ANGLES(RAD(120), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(15), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
				for i=0, 0.35, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-15)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.15, -0.5) * ANGLES(RAD(40), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5, -0.3) * ANGLES(RAD(120), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(15), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				end
			end
		else
			for i=0, 0.5, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			WELD:remove()
			for i=0, 0.15, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-110)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			Debris:AddItem(SCREW,6)
		end
		ATTACK = false
		Rooted = false
	end

	--//=================================\\
	--||	  ASSIGN THINGS TO KEYS
	--\\=================================//

	function MouseDown(Mouse)
		if ATTACK == false then
		end
	end

	function MouseUp(Mouse)
		HOLD = false
	end

	function KeyDown(Key)
		KEYHOLD = true
		if Key == "z" and ATTACK == false then
			Warp()
		end

		if Key == "b" and ATTACK == false then
			Dash()
		end

		if Key == "c" and ATTACK == false then
			LimbRip()
		end

		if Key == "v" and ATTACK == false then
			Buzzsaw()
		end

		if Key == "e" and ATTACK == false then
			ReeeEEEEEE()
		end

		if Key == "x" and ATTACK == false then
			Needle()
		end

		if Key == "t" and ATTACK == false then
			ScrewThis()
		end
	end

	function KeyUp(Key)
		KEYHOLD = false
	end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

	--//=================================\\
	--\\=================================//

	function AntiTimeStop()
		for _, c in pairs(Character:GetChildren()) do
			if c:IsA("BasePart") then
				c.Anchored = false
			end
		end
		for _, c in pairs(Weapon:GetChildren()) do
			if c:IsA("BasePart") then
				c.Anchored = false
			end
		end
	end

	--//=================================\\
	--||	WRAP THE WHOLE SCRIPT UP
	--\\=================================//

	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)

	local sick = IT("Sound")

	while true do
		Swait()
		script.Parent = WEAPONGUI
		ANIMATE.Parent = nil
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		SINE = SINE + CHANGE
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		if ANIM == "Walk" and TORSOVELOCITY > 1 then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.2- 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(90 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(90 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		end
		if HITFLOOR == nil then
			ANIM = "Midair"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.75, 0) * ANGLES(RAD(-15), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.75, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.2, -0.6) * ANGLES(RAD(15), RAD(70), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.2, -0.6) * ANGLES(RAD(15), RAD(-70), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(10 - 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(-15), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE))), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(-10 * COS(SINE / WALKSPEEDVALUE))), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0.5 * SIN(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * ANGLES(RAD(0), RAD(-15), RAD(0)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5 * SIN(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
			end
		end
		Humanoid.MaxHealth = "inf"
		Humanoid.Health = "inf"
		sick.SoundId = "rbxassetid://1696854181"
		sick.Looped = true
		sick.Pitch = 1
		sick.Volume = 2
		sick.Playing = true
		sick.Parent = Effects
		AntiTimeStop()
		refit()
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		---Humanoid.Name = "Killbot"
		--end
	end

	--//=================================\\
	--\\=================================//

	--//====================================================\\--
	--||			  		 END OF SCRIPT
	--\\====================================================//--
end)

Sonc.Name = "Sonc"
Sonc.Parent = Frame
Sonc.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Sonc.Position = UDim2.new(0.399864376, 0, 0.478283256, 0)
Sonc.Size = UDim2.new(0, 106, 0, 44)
Sonc.Font = Enum.Font.SourceSans
Sonc.Text = "Sonic runner"
Sonc.TextColor3 = Color3.fromRGB(0, 0, 0)
Sonc.TextSize = 20.000
Sonc.MouseButton1Down:connect(function()

	-- [ SANIIIC HES ON DA RAWN ] --
	wait()
	thing = 0
	LoudVolume = false
	Submerged = false
	Music = true
	script.Name = "SANIIIIC"
	Player = game.Players.LocalPlayer
	c = game.Players.LocalPlayer.Character
	Head = c.Head
	Humanoid = c.Humanoid
	anim = c.Humanoid.Animator
	rage = false
	p = game.Players.LocalPlayer
	Music = false
	anim = Humanoid.Animator
	local Effects = {}
	attack = false
	local attacking = false
	vt = Vector3.new
	bc = BrickColor.new
	br = BrickColor.random
	it = Instance.new
	cf = CFrame.new
	euler = CFrame.fromEulerAnglesXYZ
	angles = CFrame.Angles
	matr = math.random
	mouse = Player:GetMouse()

	RSC0 = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
	RSC1 = CFrame.new(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
	LSC0 = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
	LSC1 = CFrame.new(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
	RHC0 = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
	RHC1 = CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
	LHC0 = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
	LHC1 = CFrame.new(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
	NC0 = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	NC1 = CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	RJC0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	RJC1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	RS = c.Torso:FindFirstChild("Right Shoulder")
	LS = c.Torso:FindFirstChild("Left Shoulder")
	RH = c.Torso:FindFirstChild("Right Hip")
	LH = c.Torso:FindFirstChild("Left Hip")
	RJ = c.HumanoidRootPart:FindFirstChild("RootJoint")
	N = c.Torso:FindFirstChild("Neck")
	cf = CFrame.new
	ang = CFrame.Angles
	rd = math.rad
	rd2 = math.random

--[[mainShirt = c.Shirt
mainPants = c.Pants
mainBColors = c["Body Colors"]
mainShirt.ShirtTemplate = "rbxassetid://769869277"
mainPants.PantsTemplate = "rbxassetid://805486769"
mainBColors.HeadColor = BrickColor.new("Pastel brown")
mainBColors.LeftArmColor = BrickColor.new("Pastel brown")
mainBColors.LeftLegColor = BrickColor.new("Pastel brown")
mainBColors.RightArmColor = BrickColor.new("Pastel brown")
mainBColors.RightLegColor = BrickColor.new("Pastel brown")
mainBColors.TorsoColor = BrickColor.new("Pastel brown")]]
	function swait(num)
		if num==0 or num==nil then
			game:service'RunService'.Heartbeat:wait(0)
		else
			for i=0,num do
				game:service'RunService'.Heartbeat:wait(0)
			end
		end
	end

	function lerpz(joint, prop, cfrmz, alp)
		joint[prop] = joint[prop]:lerp(cfrmz, alp)
	end
	function resetlerp()
		RJ.C0 = RJC0
		RJ.C1 = RJC1
		N.C0 = NC0
		N.C1 = NC1
		RS.C0 = RSC0
		RS.C1 = RSC1
		LS.C0 = LSC0
		LS.C1 = LSC1
		RH.C0 = RHC0
		RH.C1 = RHC1
		LH.C0 = LHC0
		LH.C1 = LHC1
	end

	local S2 = Instance.new("Sound",c.HumanoidRootPart)S2.SoundId = "rbxassetid://1246460167" S2.Volume = 0 S2.PlaybackSpeed = 0 S2.Looped = true S2:Play()
	c.Head.face:remove()

	local ColorArray = {ColorSequenceKeypoint.new(0, Color3.new(0/255,170/255,255/255)),ColorSequenceKeypoint.new(1, Color3.new(0/255,170/255,255/255))}
	local att1 = Instance.new("Attachment", c["Right Leg"])
	att1.Name = "att1"
	att1.Position = Vector3.new(0.5, 1, 0.5)
	local att2 = Instance.new("Attachment", c["Right Leg"])
	att2.Name = "att2"
	att2.Position = Vector3.new(-0.5, 1, 0.5)
	local att3 = Instance.new("Attachment", c["Right Leg"])
	att3.Name = "att3"
	att3.Position = Vector3.new(0.5, -1, 0.5)
	local att4 = Instance.new("Attachment", c["Right Leg"])
	att4.Name = "att4"
	att4.Position = Vector3.new(-0.5, -1, 0.5)

	local attt1 = Instance.new("Attachment", c["Left Leg"])
	attt1.Name = "att1"
	attt1.Position = Vector3.new(0.5, 1, 0.5)
	local attt2 = Instance.new("Attachment", c["Left Leg"])
	attt2.Name = "att2"
	attt2.Position = Vector3.new(-0.5, 1, 0.5)
	local attt3 = Instance.new("Attachment", c["Left Leg"])
	attt3.Name = "att3"
	attt3.Position = Vector3.new(0.5, -1, 0.5)
	local attt4 = Instance.new("Attachment", c["Left Leg"])
	attt4.Name = "att4"
	attt4.Position = Vector3.new(-0.5, -1, 0.5)

	local trailtop1 = Instance.new("Trail", c["Right Leg"])
	trailtop1.Enabled = true
	trailtop1.Texture = "rbxassetid://16607923"
	trailtop1.Name = "toptrail"
	trailtop1.MinLength = 0
	trailtop1.Lifetime = 0.1

	trailtop1.Color = ColorSequence.new(ColorArray)

	trailtop1.Attachment0 = att1
	trailtop1.Attachment1 = att2
	trailtop1.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailbot1 = Instance.new("Trail", c["Right Leg"])
	trailbot1.Enabled = true
	trailbot1.Texture = "rbxassetid://16607923"
	trailbot1.Name = "bottrail"
	trailbot1.MinLength = 0
	trailbot1.Lifetime = 0.1

	trailbot1.Color = ColorSequence.new(ColorArray)

	trailbot1.Attachment0 = att3
	trailbot1.Attachment1 = att4
	trailbot1.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailside1 = Instance.new("Trail", c["Right Leg"])
	trailside1.Enabled = true
	trailside1.Texture = "rbxassetid://16607923"
	trailside1.Name = "sidetrail1"
	trailside1.MinLength = 0
	trailside1.Lifetime = 0.1

	trailside1.Color = ColorSequence.new(ColorArray)

	trailside1.Attachment0 = att1
	trailside1.Attachment1 = att3
	trailside1.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailside2 = Instance.new("Trail", c["Right Leg"])
	trailside2.Enabled = true
	trailside2.Texture = "rbxassetid://16607923"
	trailside2.Name = "sidetrail2"
	trailside2.MinLength = 0
	trailside2.Lifetime = 0.1
	spawn(function()
		while true do wait()
			trailside2.Color = ColorSequence.new(ColorArray)
		end
	end)
	trailside2.Attachment0 = att2
	trailside2.Attachment1 = att4
	trailside2.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})


	local trailtop12 = Instance.new("Trail", c["Left Leg"])
	trailtop12.Enabled = true
	trailtop12.Texture = "rbxassetid://16607923"
	trailtop12.Name = "toptrail"
	trailtop12.MinLength = 0
	trailtop12.Lifetime = 0.1
	spawn(function()
		while true do wait()
			trailtop12.Color = ColorSequence.new(ColorArray)
		end
	end)
	trailtop12.Attachment0 = attt1
	trailtop12.Attachment1 = attt2
	trailtop12.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailbot2 = Instance.new("Trail", c["Left Leg"])
	trailbot2.Enabled = true
	trailbot2.Texture = "rbxassetid://16607923"
	trailbot2.Name = "bottrail"
	trailbot2.MinLength = 0
	trailbot2.Lifetime = 0.1

	trailbot2.Color = ColorSequence.new(ColorArray)

	trailbot2.Attachment0 = attt3
	trailbot2.Attachment1 = attt4
	trailbot2.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailside12 = Instance.new("Trail", c["Left Leg"])
	trailside12.Enabled = true
	trailside12.Texture = "rbxassetid://16607923"
	trailside12.Name = "sidetrail1"
	trailside12.MinLength = 0
	trailside12.Lifetime = 0.1

	trailside12.Color = ColorSequence.new(ColorArray)

	trailside12.Attachment0 = attt1
	trailside12.Attachment1 = attt3
	trailside12.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailside22 = Instance.new("Trail", c["Left Leg"])
	trailside22.Enabled = true
	trailside22.Texture = "rbxassetid://16607923"
	trailside22.Name = "sidetrail2"
	trailside22.MinLength = 0
	trailside22.Lifetime = 0.1

	trailside22.Color = ColorSequence.new(ColorArray)

	trailside22.Attachment0 = attt2
	trailside22.Attachment1 = attt4
	trailside22.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})


	local att1 = Instance.new("Attachment", c["Right Arm"])
	att1.Name = "att1"
	att1.Position = Vector3.new(0.5, 1, 0.5)
	local att2 = Instance.new("Attachment", c["Right Arm"])
	att2.Name = "att2"
	att2.Position = Vector3.new(-0.5, 1, 0.5)
	local att3 = Instance.new("Attachment", c["Right Arm"])
	att3.Name = "att3"
	att3.Position = Vector3.new(0.5, -1, 0.5)
	local att4 = Instance.new("Attachment", c["Right Arm"])
	att4.Name = "att4"
	att4.Position = Vector3.new(-0.5, -1, 0.5)

	local attt1 = Instance.new("Attachment", c["Left Arm"])
	attt1.Name = "att1"
	attt1.Position = Vector3.new(0.5, 1, 0.5)
	local attt2 = Instance.new("Attachment", c["Left Arm"])
	attt2.Name = "att2"
	attt2.Position = Vector3.new(-0.5, 1, 0.5)
	local attt3 = Instance.new("Attachment", c["Left Arm"])
	attt3.Name = "att3"
	attt3.Position = Vector3.new(0.5, -1, 0.5)
	local attt4 = Instance.new("Attachment", c["Left Arm"])
	attt4.Name = "att4"
	attt4.Position = Vector3.new(-0.5, -1, 0.5)

	local trailtop1 = Instance.new("Trail", c["Right Arm"])
	trailtop1.Enabled = true
	trailtop1.Texture = "rbxassetid://16607923"
	trailtop1.Name = "toptrail"
	trailtop1.MinLength = 0
	trailtop1.Lifetime = 0.1

	trailtop1.Color = ColorSequence.new(ColorArray)

	trailtop1.Attachment0 = att1
	trailtop1.Attachment1 = att2
	trailtop1.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailbot1 = Instance.new("Trail", c["Right Arm"])
	trailbot1.Enabled = true
	trailbot1.Texture = "rbxassetid://16607923"
	trailbot1.Name = "bottrail"
	trailbot1.MinLength = 0
	trailbot1.Lifetime = 0.1
	spawn(function()
		while true do wait()
			trailbot1.Color = ColorSequence.new(ColorArray)
		end
	end)
	trailbot1.Attachment0 = att3
	trailbot1.Attachment1 = att4
	trailbot1.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailside1 = Instance.new("Trail", c["Right Arm"])
	trailside1.Enabled = true
	trailside1.Texture = "rbxassetid://16607923"
	trailside1.Name = "sidetrail1"
	trailside1.MinLength = 0
	trailside1.Lifetime = 0.1

	trailside1.Color = ColorSequence.new(ColorArray)

	trailside1.Attachment0 = att1
	trailside1.Attachment1 = att3
	trailside1.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailside2 = Instance.new("Trail", c["Right Arm"])
	trailside2.Enabled = true
	trailside2.Texture = "rbxassetid://16607923"
	trailside2.Name = "sidetrail2"
	trailside2.MinLength = 0
	trailside2.Lifetime = 0.1

	trailside2.Color = ColorSequence.new(ColorArray)

	trailside2.Attachment0 = att2
	trailside2.Attachment1 = att4
	trailside2.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})


	local trailtop12 = Instance.new("Trail", c["Left Arm"])
	trailtop12.Enabled = true
	trailtop12.Texture = "rbxassetid://16607923"
	trailtop12.Name = "toptrail"
	trailtop12.MinLength = 0
	trailtop12.Lifetime = 0.1

	trailtop12.Color = ColorSequence.new(ColorArray)

	trailtop12.Attachment0 = attt1
	trailtop12.Attachment1 = attt2
	trailtop12.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailbot2 = Instance.new("Trail", c["Left Arm"])
	trailbot2.Enabled = true
	trailbot2.Texture = "rbxassetid://16607923"
	trailbot2.Name = "bottrail"
	trailbot2.MinLength = 0
	trailbot2.Lifetime = 0.1

	trailbot2.Color = ColorSequence.new(ColorArray)

	trailbot2.Attachment0 = attt3
	trailbot2.Attachment1 = attt4
	trailbot2.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailside12 = Instance.new("Trail", c["Left Arm"])
	trailside12.Enabled = true
	trailside12.Texture = "rbxassetid://16607923"
	trailside12.Name = "sidetrail1"
	trailside12.MinLength = 0
	trailside12.Lifetime = 0.1

	trailside12.Color = ColorSequence.new(ColorArray)

	trailside12.Attachment0 = attt1
	trailside12.Attachment1 = attt3
	trailside12.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})

	local trailside22 = Instance.new("Trail", c["Left Arm"])
	trailside22.Enabled = true
	trailside22.Texture = "rbxassetid://16607923"
	trailside22.Name = "sidetrail2"
	trailside22.MinLength = 0
	trailside22.Lifetime = 0.1

	trailside22.Color = ColorSequence.new(ColorArray)

	trailside22.Attachment0 = attt2
	trailside22.Attachment1 = attt4
	trailside22.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})	

	local att1 = Instance.new("Attachment", c["Torso"])
	att1.Name = "att1"
	att1.Position = Vector3.new(1, 1, 0.5)
	local att2 = Instance.new("Attachment", c["Torso"])
	att2.Name = "att2"
	att2.Position = Vector3.new(-1, 1, 0.5)
	local att3 = Instance.new("Attachment", c["Torso"])
	att3.Name = "att3"
	att3.Position = Vector3.new(1, -1, 0.5)
	local att4 = Instance.new("Attachment", c["Torso"])
	att4.Name = "att4"
	att4.Position = Vector3.new(-1, -1, 0.5)

	local attt1 = Instance.new("Attachment", c["Head"])
	attt1.Name = "att1"
	attt1.Position = Vector3.new(.55, .55, 0.025)
	local attt2 = Instance.new("Attachment", c["Head"])
	attt2.Name = "att2"
	attt2.Position = Vector3.new(-.55, .55, 0.025)
	local attt3 = Instance.new("Attachment", c["Head"])
	attt3.Name = "att3"
	attt3.Position = Vector3.new(.55, -.5, 0.025)
	local attt4 = Instance.new("Attachment", c["Head"])
	attt4.Name = "att4"
	attt4.Position = Vector3.new(-.55, -.5, 0.025)
	local trailtop1 = Instance.new("Trail", c["Torso"])
	trailtop1.Enabled = true
	trailtop1.Texture = "rbxassetid://16607923"
	trailtop1.Name = "toptrail"
	trailtop1.MinLength = 0
	trailtop1.Lifetime = 0.1

	trailtop1.Color = ColorSequence.new(ColorArray)

	trailtop1.Attachment0 = att1
	trailtop1.Attachment1 = att2
	trailtop1.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})
	local trailbot1 = Instance.new("Trail", c["Torso"])
	trailbot1.Enabled = true
	trailbot1.Texture = "rbxassetid://16607923"
	trailbot1.Name = "bottrail"
	trailbot1.MinLength = 0
	trailbot1.Lifetime = 0.1

	trailbot1.Color = ColorSequence.new(ColorArray)

	trailbot1.Attachment0 = att3
	trailbot1.Attachment1 = att4
	trailbot1.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})
	local trailside1 = Instance.new("Trail", c["Torso"])
	trailside1.Enabled = true
	trailside1.Texture = "rbxassetid://16607923"
	trailside1.Name = "sidetrail1"
	trailside1.MinLength = 0
	trailside1.Lifetime = 0.1

	trailside1.Color = ColorSequence.new(ColorArray)

	trailside1.Attachment0 = att1
	trailside1.Attachment1 = att3
	trailside1.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})
	local trailside2 = Instance.new("Trail", c["Torso"])
	trailside2.Enabled = true
	trailside2.Texture = "rbxassetid://16607923"
	trailside2.Name = "sidetrail2"
	trailside2.MinLength = 0
	trailside2.Lifetime = 0.1

	trailside2.Color = ColorSequence.new(ColorArray)

	trailside2.Attachment0 = att2
	trailside2.Attachment1 = att4
	trailside2.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})
	local trailtop12 = Instance.new("Trail", c["Head"])
	trailtop12.Enabled = true
	trailtop12.Texture = "rbxassetid://16607923"
	trailtop12.Name = "toptrail"
	trailtop12.MinLength = 0
	trailtop12.Lifetime = 0.1

	trailtop12.Color = ColorSequence.new(ColorArray)

	trailtop12.Attachment0 = attt1
	trailtop12.Attachment1 = attt2
	trailtop12.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})
	local trailbot2 = Instance.new("Trail", c["Head"])
	trailbot2.Enabled = true
	trailbot2.Texture = "rbxassetid://16607923"
	trailbot2.Name = "bottrail"
	trailbot2.MinLength = 0
	trailbot2.Lifetime = 0.1

	trailbot2.Color = ColorSequence.new(ColorArray)

	trailbot2.Attachment0 = attt3
	trailbot2.Attachment1 = attt4
	trailbot2.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})
	local trailside12 = Instance.new("Trail", c["Head"])
	trailside12.Enabled = true
	trailside12.Texture = "rbxassetid://16607923"
	trailside12.Name = "sidetrail1"
	trailside12.MinLength = 0
	trailside12.Lifetime = 0.1

	trailside12.Color = ColorSequence.new(ColorArray)

	trailside12.Attachment0 = attt1
	trailside12.Attachment1 = attt3
	trailside12.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5, 0),
		NumberSequenceKeypoint.new(1, 1, 0)
	})
	local trailside22 = Instance.new("Trail", c["Head"])
	trailside22.Enabled = true
	trailside22.Texture = "rbxassetid://16607923"
	trailside22.Name = "sidetrail2"
	trailside22.MinLength = 0
	trailside22.Lifetime = 0.1

	trailside22.Color = ColorSequence.new(ColorArray)

	trailside22.Attachment0 = attt2 trailside22.Attachment1 = attt4
	trailside22.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.5, 0),NumberSequenceKeypoint.new(1, 1, 0)})

	Sped = 0

	function ragplayer(cactus)
		local S = Instance.new("Sound",c.HumanoidRootPart)S.SoundId = "rbxassetid://131026421" S.Volume = 2 S:Play()
		cactus.Humanoid.PlatformStand = true cactus:findFirstChild("Humanoid").Health = 0.01
		if cactus["Right Arm"]~=nil and cactus.Torso:FindFirstChild("Right Shoulder") then
			cactus.Torso:FindFirstChild("Right Shoulder"):Destroy()
			makegloo(cactus.Torso, RSC0, RSC1, cactus.Torso, cactus["Right Arm"], "Right Shoulder")
			maketouchy(cactus["Right Arm"], cactus["Right Arm"], CFrame.new(0, 0.5, 0))
		end
		if cactus["Left Arm"]~=nil and cactus.Torso:FindFirstChild("Left Shoulder") then
			cactus.Torso:FindFirstChild("Left Shoulder"):Destroy()
			makegloo(cactus.Torso, LSC0, LSC1, cactus.Torso, cactus["Left Arm"], "Left Shoulder")
			maketouchy(cactus["Left Arm"], cactus["Left Arm"], CFrame.new(0, 0.5, 0))
		end
		if cactus["Right Leg"]~=nil and cactus.Torso:FindFirstChild("Right Hip") then
			cactus.Torso:FindFirstChild("Right Hip"):Destroy()
			makegloo(cactus.Torso, RHC0, RHC1, cactus.Torso, cactus["Right Leg"], "Right Hip")
			maketouchy(cactus["Right Leg"], cactus["Right Leg"], CFrame.new(0, 0.5, 0))
		end
		if cactus["Left Leg"]~=nil and cactus.Torso:FindFirstChild("Left Hip") then
			cactus.Torso:FindFirstChild("Left Hip"):Destroy()
			makegloo(cactus.Torso, LHC0, LHC1, cactus.Torso, cactus["Left Leg"], "Left Hip")
			maketouchy(cactus["Left Leg"], cactus["Left Leg"], CFrame.new(0, 0.5, 0))
		end
		cactus.Parent = game.Workspace game.Debris:AddItem(cactus,15)
	end
	function makegloo(paren, co, ci, parto, parti, nam) local gloo = Instance.new("Glue") gloo.Name = nam gloo.C0 = co gloo.C1 = ci gloo.Part0 = parto gloo.Part1 = parti gloo.Parent = paren end

	function maketouchy(parent, limb, cframe) local pr = Instance.new("Part") pr.Name = "touchy" pr.Size = Vector3.new(1, 1, 1) pr.Transparency = 1 pr.CustomPhysicalProperties = PhysicalProperties.new(0.55, 0.3, 0.5) pr.CanCollide = true pr.Anchored = false pr.Parent = parent local w = Instance.new("Weld") w.Part0 = pr w.Part1 = limb w.C0 = cframe w.Parent = pr end

	local hitz = false
	c.HumanoidRootPart.Touched:connect(function(Hit)
		if thing >= 100 then 
			if hitz == false then hitz = true
				ragplayer(c) local S = Instance.new("Sound",c.HumanoidRootPart)S.SoundId = "rbxassetid://386946017" S.Volume = 6 S:Play()
				wait(15)
			end
		end
	end)

	function Spin()
		attack = true
		while attack == true do Sped = Sped + 0.25
			lerpz(RJ, "C0", RJC0 * cf(0, 0, 0) * ang(rd(Sped*Sped*5), rd(0), rd(0)), 1)
			lerpz(N, "C0", NC0 * cf(0, 0, 0) * ang(rd(60), rd(0), rd(0)), 1)
			lerpz(RS, "C0", RSC0 * cf(0, 0, 0) * ang(rd(15), rd(25), rd(25)), 1)
			lerpz(RS, "C1", RSC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
			lerpz(LS, "C0", LSC0 * cf(0, 0, 0) * ang(rd(15), rd(-25), rd(-25)), 1)
			lerpz(LS, "C1", LSC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
			lerpz(RH, "C0", RHC0 * cf(0.5, 1.5, 0) * ang(rd(0), rd(0), rd(0)), 1)
			lerpz(RH, "C1", RHC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
			lerpz(LH, "C0", LHC0 * cf(-0.5, 1.5, 0) * ang(rd(0), rd(0), rd(0)), 1)
			lerpz(LH, "C1", LHC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
			swait()
		end
	end

	SanicScreams = {585370931,202427593}	

	mouse.KeyDown:connect(function(key)
		if attack == true then return end
		if key == "q" then
			Spin()
		end
		if key == "e" then
			local S = Instance.new("Sound",c.HumanoidRootPart)S.SoundId = "rbxassetid://537371462" S.Volume = 10 S:Play()
			wait(1.25)
			local Sanic  = SanicScreams[math.random(1,#SanicScreams)]
			local S = Instance.new("Sound",c.HumanoidRootPart)S.SoundId = "rbxassetid://"..Sanic S.Volume = 10 S:Play()
			spawn(function()
				local Sp = Instance.new("Part",game.Workspace)Sp.BrickColor = BrickColor.new("Cyan")Sp.Material = "Neon" Sp.Size = Vector3.new(1,1,1) Sp.Anchored = true Sp.CanCollide = false
				local SPM = Instance.new("SpecialMesh",Sp)SPM.MeshType = "Sphere" Sp.CFrame = c.HumanoidRootPart.CFrame
				for i = 1,25 do
					SPM.Scale = SPM.Scale + Vector3.new(4,4,4)
					Sp.Transparency = Sp.Transparency + 1/25
					swait()
				end
			end)
			local S = Instance.new("Sound",c.HumanoidRootPart)S.SoundId = "rbxassetid://214444596" S.Volume = 10 S:Play()
			Sped = 10000000000
		end
	end)

	mouse.KeyUp:connect(function(key)
		if key == "q" then
			attack = false
		end
	end)

	local P = Instance.new("Part",game.Workspace.CurrentCamera)P.CanCollide = true P.Anchored = true P.Size = Vector3.new(15,1,15)
	P.CFrame = CFrame.new(c.HumanoidRootPart.Position)*CFrame.new(0,-3.5,0)P.Transparency = 0 P.Name = "FlightPart"
	P.BrickColor = BrickColor.new("Dark green") P.TopSurface = "Smooth" P.Material = "Grass"
	spawn(function()
		while true do
			P.CFrame = CFrame.new(c.HumanoidRootPart.Position.X,-0.6,c.HumanoidRootPart.Position.Z)
			swait()
		end
	end)

	anim.Parent = nil
	sine = 0

	game:GetService("RunService").RenderStepped:connect(function()
		if attack == false then
			thing = (c.HumanoidRootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
			game.Workspace.CurrentCamera.FieldOfView = 70+thing/100
			if c.HumanoidRootPart.Velocity.Y > 1 then sine = sine + 1
				lerpz(RJ, "C0", RJC0 * cf(0, 0, 0) * ang(rd(sine*thing*0.75), rd(0), rd(0)), 1)
				lerpz(N, "C0", NC0 * cf(0, 0, 0) * ang(rd(60), rd(0), rd(0)), 1)
				lerpz(RS, "C0", RSC0 * cf(0, 0, 0) * ang(rd(15), rd(25), rd(25)), 1)
				lerpz(RS, "C1", RSC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
				lerpz(LS, "C0", LSC0 * cf(0, 0, 0) * ang(rd(15), rd(-25), rd(-25)), 1)
				lerpz(LS, "C1", LSC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
				lerpz(RH, "C0", RHC0 * cf(0.5, 1.5, 0) * ang(rd(0), rd(0), rd(0)), 1)
				lerpz(RH, "C1", RHC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
				lerpz(LH, "C0", LHC0 * cf(-0.5, 1.5, 0) * ang(rd(0), rd(0), rd(0)), 1)
				lerpz(LH, "C1", LHC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
			elseif (c.HumanoidRootPart.Velocity * Vector3.new(1, 0, 1)).magnitude > 2 then
				sine = sine + 1 Sped = Sped + 0.1
				if thing <= 200 then
					if S2.PlaybackSpeed >= 1 then
						S2.PlaybackSpeed = 1
					else 
						S2.PlaybackSpeed = thing/80
					end
					c.Humanoid.WalkSpeed = 16+(thing/1.5)+Sped
					S2.Volume = thing/20
				end
				if thing <= 200 then
					c.Humanoid.WalkSpeed = 16+(thing/1.5)+Sped
					S2.Volume = thing/20
				else
					c.Humanoid.WalkSpeed = 16+(thing/1.5)+Sped
				end
				if thing <= 100 then
					for i,v in pairs(c:children()) do
						if v.ClassName == "Part" then
							for i,v2 in pairs(v:children()) do
								if v2.ClassName == "Trail" then
									v2.Enabled = false
									v2.LightEmission = 1
								end
							end
						end
					end
				else
					for i,v in pairs(c:children()) do
						if v.ClassName == "Part" then
							for i,v2 in pairs(v:children()) do
								if v2.ClassName == "Trail" then
									v2.Lifetime = 2
									v2.Enabled = true
								end
							end
						end
					end
				end
				lerpz(RJ, "C0", RJC0 * cf(0, 0, 0) * ang(rd(thing/7), rd(0), rd(0)), 1)
				lerpz(N, "C0", NC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
				lerpz(RS, "C0", RSC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(-thing/1.5)), 1)
				lerpz(RS, "C1", RSC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
				lerpz(LS, "C0", LSC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(thing/1.5)), 1)
				lerpz(LS, "C1", LSC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
				lerpz(RH, "C0", RHC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(math.cos(sine/2))*thing/1.25), 1)
				lerpz(RH, "C1", RHC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
				lerpz(LH, "C0", LHC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(math.cos(sine/2))*thing/1.25), 1)
				lerpz(LH, "C1", LHC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 1)
			else c.Humanoid.WalkSpeed = 16 Sped = 0 sine = sine + 1 S2.Volume = 0 S2.PlaybackSpeed = 0
				lerpz(RJ, "C0", RJC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 0.5)
				lerpz(N, "C0", NC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 0.5)
				lerpz(RS, "C0", RSC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(math.cos(sine/24)*4)), 0.5)
				lerpz(RS, "C1", RSC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 0.5)
				lerpz(LS, "C0", LSC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(math.cos(sine/24)*4)), 0.5)
				lerpz(LS, "C1", LSC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 0.5)
				lerpz(RH, "C0", RHC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 0.5)
				lerpz(RH, "C1", RHC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 0.5)
				lerpz(LH, "C0", LHC0 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 0.5)
				lerpz(LH, "C1", LHC1 * cf(0, 0, 0) * ang(rd(0), rd(0), rd(0)), 0.5)
			end
			for i,v in pairs (c:children()) do
				if v.ClassName == "Accessory" then
					for i,v2 in pairs (v:children()) do
						if v2.ClassName == "Part" then
							v2.Anchored = false
						end
					end
				end
				for i,v in pairs (c:children()) do
					if v.ClassName == "Part" then
						v.Anchored = false
					end
				end
			end
		end
	end)
end)

Memeis.Name = "Memeis"
Memeis.Parent = Frame
Memeis.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Memeis.Position = UDim2.new(0.677959621, 0, 0.478283256, 0)
Memeis.Size = UDim2.new(0, 106, 0, 44)
Memeis.Font = Enum.Font.SourceSans
Memeis.Text = "Memus"
Memeis.TextColor3 = Color3.fromRGB(0, 0, 0)
Memeis.TextSize = 20.000
Memeis.MouseButton1Down:connect(function()
	-----------------------
	--MemeusV2--
	-------------------------------------------------------
	--A script By makhail07

	--This edit by 2003boobear

	--Discord Creterisk#2958 (not 2003boobear's discord)
	-------------------------------------------------------

	local FavIDs = {
		340106355, --Nefl Crystals
		927529620, --Dimension
		876981900, --Fantasy
		398987889, --Ordinary Days
		1117396305, --Oh wait, it's you.
		885996042, --Action Winter Journey
		919231299, --Sprawling Idiot Effigy
		743466274, --Good Day Sunshine
		727411183, --Knife Fight
		1402748531, --The Earth Is Counting On You!
		595230126 --Robot Language
	}



	--The reality of my life isn't real but a Universe -makhail07
	wait()
	local Player = game.Players.localPlayer
	local Character = Player.Character
	local plr = game:service'Players'.LocalPlayer
	local Humanoid = Character.Humanoid
	local char = plr.Character
	local hum = char.Humanoid
	local ra = char["Right Arm"]
	local la= char["Left Arm"]
	local rl= char["Right Leg"]
	local ll = char["Left Leg"]
	local hed = char.Head
	local root = char.HumanoidRootPart
	local rootj = root.RootJoint
	local tors = char.Torso
	local mouse = plr:GetMouse()
	local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
	local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
	local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
	local cam = game.Workspace.CurrentCamera
	trazx = Instance.new("ParticleEmitter")
	c = game.Players.LocalPlayer.Character

	--where i put all the warn things

	warn ("Well Look at that, I finished it.")
	--Looks Like you decided to look though the script. Well, Hello.
	warn ("I had a fun time making this edit.")
	--I Really DID have fun editing this.
	warn ("I hope you Enjoy this. Go have Fun!")
	--Just don't abuse.
	warn ("Also, the original MemeusV2 was made by makhail07.")
	--Support makhail07 for making the original!
	warn ("This edit was made by me, 2003boobear.")
	--This is one of my best edits BY FAR, though.
	Character.Head.face.Texture = "rbxassetid://620619801"

	-------------------------------------------------------
	--Start Good Stuff--
	-------------------------------------------------------
	CF = CFrame.new
	angles = CFrame.Angles
	attack = false
	timetofly = true
	Euler = CFrame.fromEulerAnglesXYZ
	Rad = math.rad
	IT = Instance.new
	BrickC = BrickColor.new
	Cos = math.cos
	Acos = math.acos
	Sin = math.sin
	Asin = math.asin
	Abs = math.abs
	Mrandom = math.random
	Floor = math.floor
	random = math.random
	radian = math.rad
	Vec3 = Vector3.new
	cFrame = CFrame.new
	Euler = CFrame.fromEulerAnglesXYZ
	-------------------------------------------------------
	--End Good Stuff--
	-------------------------------------------------------
	necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	RSH, LSH = nil, nil 
	RW = Instance.new("Weld") 
	LW = Instance.new("Weld")
	RH = tors["Right Hip"]
	LH = tors["Left Hip"]
	RSH = tors["Right Shoulder"] 
	LSH = tors["Left Shoulder"] 
	RSH.Parent = nil 
	LSH.Parent = nil 
	RW.Name = "RW"
	RW.Part0 = tors 
	RW.C0 = CF(1.5, 0.5, 0)
	RW.C1 = CF(0, 0.5, 0) 
	RW.Part1 = ra
	RW.Parent = tors 
	LW.Name = "LW"
	LW.Part0 = tors 
	LW.C0 = CF(-1.5, 0.5, 0)
	LW.C1 = CF(0, 0.5, 0) 
	LW.Part1 = la
	LW.Parent = tors
	Effects = {}

	-------------------------------------------------------
	--Start HeartBeat--
	-------------------------------------------------------
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"
	script:WaitForChild("Heartbeat")

	frame = 1 / 60
	tf = 0
	allowframeloss = false
	tossremainder = false


	lastframe = tick()
	script.Heartbeat:Fire()


	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	-------------------------------------------------------
	--End HeartBeat--
	-------------------------------------------------------

	function CameraEnshaking(Length, Intensity) --Took Straight from StarGlitcher!
		coroutine.resume(coroutine.create(function()
			local intensity = 1 * Intensity
			local rotM = 0.01 * Intensity
			for i = 0, Length, 0.1 do
				swait()
				intensity = intensity - 0.05 * Intensity / Length
				rotM = rotM - 5.0E-4 * Intensity / Length
				hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
				cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
			end
			Humanoid.CameraOffset = Vec3(0, 0, 0)
		end))
	end

	local joyemoji = Instance.new('ParticleEmitter', tors)
	joyemoji.VelocitySpread = 2000
	joyemoji.Lifetime = NumberRange.new(1)
	joyemoji.Speed = NumberRange.new(40)
	joy= {}
	for i=0, 19 do
		joy[#joy+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
	end
	joyemoji.Size = NumberSequence.new(joy)
	joyemoji.Rate = 0
	joyemoji.LockedToPart = false
	joyemoji.LightEmission = 0
	joyemoji.Texture = "rbxassetid://1176402123"
	joyemoji.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)


	local LIT = Instance.new('ParticleEmitter', tors)
	LIT.VelocitySpread = 2000
	LIT.Lifetime = NumberRange.new(1)
	LIT.Speed = NumberRange.new(45)
	nani= {}
	for i=0, 19 do
		nani[#nani+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
	end
	LIT.Size = NumberSequence.new(nani)
	LIT.Rate = 0
	LIT.LockedToPart = false
	LIT.LightEmission = 0
	LIT.Texture = "rbxassetid://1492670151"
	LIT.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

	local toast = Instance.new('ParticleEmitter', tors)
	toast.VelocitySpread = 2000
	toast.Lifetime = NumberRange.new(1)
	toast.Speed = NumberRange.new(60)
	toasterstoasttoast= {}
	for i=0, 19 do
		toasterstoasttoast[#toasterstoasttoast+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
	end
	toast.Size = NumberSequence.new(toasterstoasttoast)
	toast.Rate = 0
	toast.LockedToPart = false
	toast.LightEmission = 0
	toast.Texture = "rbxassetid://436096230"
	toast.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

	local ok = Instance.new('ParticleEmitter', tors)
	ok.VelocitySpread = 2000
	ok.Lifetime = NumberRange.new(1)
	ok.Speed = NumberRange.new(50)
	cool= {}
	for i=0, 19 do
		cool[#cool+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
	end
	ok.Size = NumberSequence.new(cool)
	ok.Rate = 0
	ok.LockedToPart = false
	ok.LightEmission = 0
	ok.Texture = "rbxassetid://636768448"
	ok.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

	-------------------------------------------------------
	--Start Kyu's shitty stuff--
	-------------------------------------------------------

	function ragdoll(model)
		local char = model
		torso = char.HumanoidRootPart
		torso2 = char.Torso
		LW.Parent = nil
		RW.Parent = nil
		LH.Parent = nil
		RH.Parent = nil
		if hum ~= nil then
			hum.PlatformStand = true
		end

		local Head = char:FindFirstChild("Head")
		if Head then
			local Neck = Instance.new("Weld")
			Neck.Name = "Neck"
			Neck.Part0 = torso
			Neck.Part1 = Head
			Neck.C0 = CFrame.new(0, 1.5, 0)
			Neck.C1 = CFrame.new()
			Neck.Parent = torso
		end
		local Limb = char:FindFirstChild("Right Arm")
		if Limb then

			Limb.CFrame = torso.CFrame * CFrame.new(1.5, 0, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "RightShoulder"
			Joint.Part0 = torso
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
			Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
			Joint.Parent = torso

			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = char
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb

		end
		local Limb = char:FindFirstChild("Left Arm")
		if Limb then

			Limb.CFrame = torso.CFrame * CFrame.new(-1.5, 0, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "LeftShoulder"
			Joint.Part0 = torso
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
			Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
			Joint.Parent = torso

			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = char
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb

		end
		local Limb = char:FindFirstChild("Right Leg")
		if Limb then

			Limb.CFrame = torso.CFrame * CFrame.new(0.5, -2, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "RightHip"
			Joint.Part0 = torso
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
			Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
			Joint.Parent = torso

			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = char
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb

		end
		local Limb = char:FindFirstChild("Left Leg")
		if Limb then

			Limb.CFrame = torso.CFrame * CFrame.new(-0.5, -2, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "LeftHip"
			Joint.Part0 = torso
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
			Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
			Joint.Parent = torso

			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = char
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb

		end
		--[
		local Bar = Instance.new("Part")
		Bar.TopSurface = 0
		Bar.BottomSurface = 0
		Bar.formFactor = "Symmetric"
		Bar.Size = Vector3.new(1, 1, 1)
		Bar.Transparency = 1
		Bar.CFrame = torso.CFrame * CFrame.new(0, 0.5, 0)
		Bar.Parent = char
		local Weld = Instance.new("Weld")
		Weld.Part0 = torso
		Weld.Part1 = Bar
		Weld.C0 = CFrame.new(0, 0.5, 0)
		Weld.Parent = torso
		--]]

		torso.CFrame = CFrame.new(torso.Position)*CFrame.Angles(math.rad(20),math.rad(torso.Orientation.Y),math.rad(torso.Orientation.Z))

	end

	-------------------------------------------------------
	--End Kyu's shitty stuff--
	-------------------------------------------------------

	-------------------------------------------------------
	--Start Important Functions--
	-------------------------------------------------------
	function swait(num)
		if num == 0 or num == nil then
			game:service("RunService").Stepped:wait(0)
		else
			for i = 0, num do
				game:service("RunService").Stepped:wait(0)
			end
		end
	end
	function thread(f)
		coroutine.resume(coroutine.create(f))
	end
	function clerp(a, b, t)
		local qa = {
			QuaternionFromCFrame(a)
		}
		local qb = {
			QuaternionFromCFrame(b)
		}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end
	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m00 < m11 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s
				return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end
	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end
	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp
		if cosTheta >= 1.0E-4 then
			if 1 - cosTheta > 1.0E-4 then
				local theta = math.acos(cosTheta)
				local invSinTheta = 1 / Sin(theta)
				startInterp = Sin((1 - t) * theta) * invSinTheta
				finishInterp = Sin(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		elseif 1 + cosTheta > 1.0E-4 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((t - 1) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end
	function rayCast(Position, Direction, Range, Ignore)
		return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
	end
	local RbxUtility = LoadLibrary("RbxUtility")
	local Create = RbxUtility.Create

	-------------------------------------------------------
	--Start Damage Function--
	-------------------------------------------------------
	function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
		if hit.Parent == nil then
			return
		end
		local h = hit.Parent:FindFirstChildOfClass("Humanoid")
		for _, v in pairs(hit.Parent:children()) do
			if v:IsA("Humanoid") then
				h = v
			end
		end
		if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
			warn'No R15 allowed'
			hit.Parent:FindFirstChild("Head"):BreakJoints()
		end

		if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
			if hit.Parent:findFirstChild("DebounceHit") ~= nil then
				if hit.Parent.DebounceHit.Value == true then
					return
				end
			end
			if insta == true then
				hit.Parent:FindFirstChild("Head"):BreakJoints()
			end
			local c = Create("ObjectValue"){
				Name = "creator",
				Value = game:service("Players").LocalPlayer,
				Parent = h,
			}
			game:GetService("Debris"):AddItem(c, .5)
			if HitSound ~= nil and HitPitch ~= nil then
				CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
			end
			local Damage = math.random(minim, maxim)
			local blocked = false
			local block = hit.Parent:findFirstChild("Block")
			if block ~= nil then
				if block.className == "IntValue" then
					if block.Value > 0 then
						blocked = true
						block.Value = block.Value - 1
						print(block.Value)
					end
				end
			end
			if blocked == false then
				h.Health = h.Health - Damage
				ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
			else
				h.Health = h.Health - (Damage / 2)
				ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
			end
			if Type == "Knockdown" then
				local hum = hit.Parent.Humanoid
				hum.PlatformStand = true
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(1)
					HHumanoid.PlatformStand = false
				end), hum)
				local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
				local bodvol = Create("BodyVelocity"){
					velocity = angle * knockback,
					P = 5000,
					maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
					Parent = hit,
				}
				local rl = Create("BodyAngularVelocity"){
					P = 3000,
					maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
					angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
					Parent = hit,
				}
				game:GetService("Debris"):AddItem(bodvol, .5)
				game:GetService("Debris"):AddItem(rl, .5)
			elseif Type == "Normal" then
				local vp = Create("BodyVelocity"){
					P = 500,
					maxForce = Vector3.new(math.huge, 0, math.huge),
					velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
				}
				if knockback > 0 then
					vp.Parent = hit.Parent.Torso
				end
				game:GetService("Debris"):AddItem(vp, .5)
			elseif Type == "Up" then
				local bodyVelocity = Create("BodyVelocity"){
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
					Parent = hit,
				}
				game:GetService("Debris"):AddItem(bodyVelocity, .5)
			elseif Type == "DarkUp" then
				coroutine.resume(coroutine.create(function()
					for i = 0, 1, 0.1 do
						swait()
						Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
					end
				end))
				local bodyVelocity = Create("BodyVelocity"){
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
					Parent = hit,
				}
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Snare" then
				local bp = Create("BodyPosition"){
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso,
				}
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Freeze" then
				local BodPos = Create("BodyPosition"){
					P = 50000,
					D = 1000,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso,
				}
				local BodGy = Create("BodyGyro") {
					maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
					P = 20e+003,
					Parent = hit.Parent.Torso,
					cframe = hit.Parent.Torso.CFrame,
				}
				hit.Parent.Torso.Anchored = true
				coroutine.resume(coroutine.create(function(Part) 
					swait(1.5)
					Part.Anchored = false
				end), hit.Parent.Torso)
				game:GetService("Debris"):AddItem(BodPos, 3)
				game:GetService("Debris"):AddItem(BodGy, 3)
			end
			local debounce = Create("BoolValue"){
				Name = "DebounceHit",
				Parent = hit.Parent,
				Value = true,
			}
			game:GetService("Debris"):AddItem(debounce, Delay)
			c = Create("ObjectValue"){
				Name = "creator",
				Value = Player,
				Parent = h,
			}
			game:GetService("Debris"):AddItem(c, .5)
		end
	end
	-------------------------------------------------------
	--End Damage Function--
	-------------------------------------------------------

	-------------------------------------------------------
	--Start Damage Function Customization--
	-------------------------------------------------------
	function ShowDamage(Pos, Text, Time, Color)
		local Rate = (1 / 30)
		local Pos = (Pos or Vector3.new(0, 0, 0))
		local Text = (Text or "")
		local Time = (Time or 2)
		local Color = (Color or Color3.new(1, 0, 1))
		local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
		EffectPart.Anchored = true
		local BillboardGui = Create("BillboardGui"){
			Size = UDim2.new(3, 0, 3, 0),
			Adornee = EffectPart,
			Parent = EffectPart,
		}
		local TextLabel = Create("TextLabel"){
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			Font = "Highway",
			TextColor3 = Color,
			TextScaled = true,
			Parent = BillboardGui,
		}
		game.Debris:AddItem(EffectPart, (Time))
		EffectPart.Parent = game:GetService("Workspace")
		delay(0, function()
			local Frames = (Time / Rate)
			for Frame = 1, Frames do
				wait(Rate)
				local Percent = (Frame / Frames)
				EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
				TextLabel.TextTransparency = Percent
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end)
	end
	-------------------------------------------------------
	--End Damage Function Customization--
	-------------------------------------------------------

	function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChild("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Head")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= plr.Name then
						Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=231917784", 1.2)
					end
				end
			end
		end
	end


	CFuncs = {
		Part = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part")({
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material
				})
				RemoveOutlines(Part)
				return Part
			end
		},
		Mesh = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh)({
					Parent = Part,
					Offset = OffSet,
					Scale = Scale
				})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
		},
		Mesh = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh)({
					Parent = Part,
					Offset = OffSet,
					Scale = Scale
				})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
		},
		Weld = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld")({
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1
				})
				return Weld
			end
		},
		Sound = {
			Create = function(id, par, vol, pit)
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound")({
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace
					})
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, 6)
				end))
			end
		},
		ParticleEmitter = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter")({
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread
				})
				return fp
			end
		}
	}
	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part")({
			formFactor = FormFactor,
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material
		})
		RemoveOutlines(Part)
		return Part
	end
	function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh)({
			Parent = Part,
			Offset = OffSet,
			Scale = Scale
		})
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end
	function CreateWeld(Parent, Part0, Part1, C0, C1)
		local Weld = Create("Weld")({
			Parent = Parent,
			Part0 = Part0,
			Part1 = Part1,
			C0 = C0,
			C1 = C1
		})
		return Weld
	end


	-------------------------------------------------------
	--Start Effect Function--
	-------------------------------------------------------
	EffectModel = Instance.new("Model", char)
	Effects = {
		Block = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				if Type == 1 or Type == nil then
					table.insert(Effects, {
						prt,
						"Block1",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				elseif Type == 2 then
					table.insert(Effects, {
						prt,
						"Block2",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				else
					table.insert(Effects, {
						prt,
						"Block3",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			end
		},
		Sphere = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0,0,0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Cylinder = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Wave = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3 / 60,
					y3 / 60,
					z3 / 60,
					msh
				})
			end
		},
		Ring = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Break = {
			Create = function(brickcolor, cframe, x1, y1, z1)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
				prt.Anchored = true
				prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				local num = math.random(10, 50) / 1000
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Shatter",
					num,
					prt.CFrame,
					math.random() - math.random(),
					0,
					math.random(50, 100) / 100
				})
			end
		},
		Spiral = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Push = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		}
	}
	-------------------------------------------------------
	--End Effect Function--
	-------------------------------------------------------

	function CreateSound(ID, PARENT, VOLUME, PITCH) --Very important.
		local NSound = nil
		coroutine.resume(coroutine.create(function()
			NSound = Instance.new("Sound", PARENT)
			NSound.Volume = VOLUME
			NSound.Pitch = PITCH
			NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
			swait()
			NSound:play()
			game:GetService("Debris"):AddItem(NSound, 10)
		end))
		return NSound
	end





	-------------------------------------------------------
	--End Important Functions--
	-------------------------------------------------------

	chargeup = Instance.new("Sound", hed)
	chargeup.SoundId = "http://www.roblox.com/asset/?id=527276541"
	chargeup.Volume = 10
	chargeup.Pitch = 1
	chargeup.Looped = true
	chargeup.TimePosition = 1

	meme = Instance.new("Sound", hed)
	meme.SoundId = "http://www.roblox.com/asset/?id=291151190"
	meme.Volume = 10
	meme.Pitch = 1
	meme.Looped = true
	meme.TimePosition = 1

	local ohno = Instance.new("Sound")
	ohno.Parent = hed
	ohno.Volume = 10
	ohno.Pitch = 1
	ohno.Looped = true

	local bass = Instance.new("Sound") --why
	bass.Parent = hed
	bass.Volume = 7
	bass.Pitch = 1
	bass.SoundId = "http://www.roblox.com/asset/?id=1087356234"
	bass.Looped = true

	Cause_Im_having_a_good_time_having_a_good_time = Instance.new("Sound", hed) --DONT STOP ME NOOOOOOOOOWWWWWWWW
	Cause_Im_having_a_good_time_having_a_good_time.SoundId = "http://www.roblox.com/asset/?id=672104253"
	Cause_Im_having_a_good_time_having_a_good_time.Volume = 10
	Cause_Im_having_a_good_time_having_a_good_time.Pitch = 1
	Cause_Im_having_a_good_time_having_a_good_time.Looped = false
	Cause_Im_having_a_good_time_having_a_good_time.TimePosition = 35.3

	STHAP = Instance.new("Sound", hed)
	STHAP.SoundId = "http://www.roblox.com/asset/?id=1591656314"
	STHAP.Volume = 10
	STHAP.Pitch = 1
	STHAP.Looped = false

	forevergone = Instance.new("Sound", tors)
	forevergone.SoundId = "http://www.roblox.com/asset/?id=1286436928"
	forevergone.Volume = 10
	forevergone.Pitch = 1
	forevergone.Looped = true
	forevergone.TimePosition = 24

	-------------------------------------------------------
	--Start Music Option--
	-------------------------------------------------------
	local Music = Instance.new("Sound",tors)
	Music.Volume = 2.5
	Music.SoundId = "rbxassetid://"
	Music.Looped = true
	Music.Pitch = 1 --Pitcher
	Music:Play()
	-------------------------------------------------------
	--End Music Option--
	-------------------------------------------------------
	--hi fat >:)
	-------------------------------------------------------
	--Start Attacks N Stuff--
	-------------------------------------------------------
	local sine=0
	function HitboxFunction(Pose, lifetime, siz1, siz2, siz3, Radie, Min, Max, kb, atype)
		local Hitboxpart = Instance.new("Part", EffectModel)
		RemoveOutlines(Hitboxpart)
		Hitboxpart.Size = Vector3.new(siz1, siz2, siz3)
		Hitboxpart.CanCollide = false
		Hitboxpart.Transparency = 1
		Hitboxpart.Anchored = true
		Hitboxpart.CFrame = Pose
		game:GetService("Debris"):AddItem(Hitboxpart, lifetime)
		MagniDamage(Hitboxpart, Radie, Min, Max, kb, atype)
	end
	function GEtOuT()
		attack = true
		hum.WalkSpeed = 10
		Character.Head.face.Texture = "rbxassetid://494811799"
		CreateSound("814652778", hed, 10, 1)
		CreateSound("537371462", hed, 10, 1)
		local vel3 = Instance.new("BodyVelocity",tors)
		vel3.Velocity = Vector3.new(0,25,0)
		vel3.MaxForce = Vector3.new(10000000,10000000,10000000)
		for i = 0,12,0.1 do
			swait()
			CameraEnshaking(1, 2)
			HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 20, 99, 53, "Knockdown")
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0-255.45*i)), 0.3)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-40), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -0.3) * LHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
			RH.C0 = clerp(RH.C0, CF(1, -1, 0.3) * angles(Rad(0), Rad(90), Rad(-20)), 0.3)
		end
		vel3:Destroy()
		Character.Head.face.Texture = "rbxassetid://620619801"
		attack = false
		Humanoid.JumpPower = 50
		hum.WalkSpeed = 16
	end

	function GEtOuT2()
		attack = true
		hum.WalkSpeed = 10
		Humanoid.JumpPower = 0
		Character.Head.face.Texture = "rbxassetid://494811799"
		CreateSound("814652778", hed, 10, 1)
		CreateSound("537371462", hed, 10, 1)
		root.Velocity = root.CFrame.lookVector * 20
		for i = 0,12,0.1 do
			swait()
			CameraEnshaking(1, 2)
			root.Velocity = root.CFrame.lookVector * 50
			HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 10, 50, 53, "Knockdown")
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(0-255.45*i)), 0.3)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-40), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -0.3) * LHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
			RH.C0 = clerp(RH.C0, CF(1, -1, 0.3) * angles(Rad(0), Rad(90), Rad(-20)), 0.3)
		end
		Character.Head.face.Texture = "rbxassetid://620619801"
		attack = false
		Humanoid.JumpPower = 50
		hum.WalkSpeed = 16
	end
	function Flight() --wowthatsdiffrent
		attack = true
		Character.Head.face.Texture = "rbxassetid://269748407"
		local ColorsArray ={ColorSequenceKeypoint.new(0, Color3.new(1,0,0)),
			ColorSequenceKeypoint.new(0.16, Color3.new(1,1,1)),
			ColorSequenceKeypoint.new(0.32, Color3.new(0,0,1)),
			ColorSequenceKeypoint.new(0.48, Color3.new(1,1,1)),
			ColorSequenceKeypoint.new(0.64, Color3.new(1,0,0)),
			ColorSequenceKeypoint.new(0.80, Color3.new(1,1,1)),
			ColorSequenceKeypoint.new(0.96, Color3.new(0,0,1)),
			ColorSequenceKeypoint.new(1, Color3.new(1,1,1))}
		local vel4 = Instance.new("BodyVelocity",ll)
		vel4.Velocity = Vector3.new(0,4,0)
		vel4.MaxForce = Vector3.new(10000000,10000000,10000000)
		local Atch3 = Instance.new("Attachment",ll)Atch3.Position = Vector3.new(0,0.6,0)
		local Atch4 = Instance.new("Attachment",ll)Atch4.Position = Vector3.new(0,-0.6,0)
		local Trail2 = Instance.new("Trail",ll)Trail2.Attachment0 = Atch3 Trail2.Attachment1 = Atch4
		Trail2.Texture = "rbxassetid://22636887" Trail2.Lifetime = 0.2 Trail2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
		Trail2.Color = ColorSequence.new(ColorsArray) Trail2.LightEmission = 1 
		Trail2.Enabled = true
		local Atch5 = Instance.new("Attachment",rl)Atch5.Position = Vector3.new(0,0.6,0)
		local Atch6 = Instance.new("Attachment",rl)Atch6.Position = Vector3.new(0,-0.6,0)
		local Trail3 = Instance.new("Trail",rl)Trail3.Attachment0 = Atch5 Trail3.Attachment1 = Atch6
		Trail3.Texture = "rbxassetid://22636887" Trail3.Lifetime = 0.2 Trail3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
		Trail3.Color = ColorSequence.new(ColorsArray) Trail3.LightEmission = 1 
		Trail3.Enabled = true
		local Atch7 = Instance.new("Attachment",ra)Atch7.Position = Vector3.new(0,0.6,0)
		local Atch8 = Instance.new("Attachment",ra)Atch8.Position = Vector3.new(0,-0.6,0)
		local Trail4 = Instance.new("Trail",ra)Trail4.Attachment0 = Atch7 Trail4.Attachment1 = Atch8
		Trail4.Texture = "rbxassetid://22636887" Trail4.Lifetime = 0.2 Trail4.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
		Trail4.Color = ColorSequence.new(ColorsArray) Trail4.LightEmission = 1 
		Trail4.Enabled = true
		local Atch9 = Instance.new("Attachment",la)Atch9.Position = Vector3.new(0,0.6,0)
		local Atch10 = Instance.new("Attachment",la)Atch10.Position = Vector3.new(0,-0.6,0)
		local Trail5 = Instance.new("Trail",la)Trail5.Attachment0 = Atch9 Trail5.Attachment1 = Atch10
		Trail5.Texture = "rbxassetid://22636887" Trail5.Lifetime = 0.2 Trail5.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
		Trail5.Color = ColorSequence.new(ColorsArray) Trail5.LightEmission = 1 
		Trail5.Enabled = true
		local Atch1 = Instance.new("Attachment",Torso)Atch1.Position = Vector3.new(0,2,0)
		local Atch2 = Instance.new("Attachment",Torso)Atch2.Position = Vector3.new(0,-2.5,0)
		local Trail = Instance.new("Trail",Torso)Trail.Attachment0 = Atch1 Trail.Attachment1 = Atch2
		Trail.Texture = "rbxassetid://22636887" Trail.Lifetime = 0.2 Trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
		Trail.Color = ColorSequence.new(ColorsArray) Trail.LightEmission = 1 
		Trail.Enabled = false
		ragdoll(char)
		wait(1)
		Character.Head.face.Texture = "rbxassetid://249062487"
		CreateSound("948494432", hed, 10, 1)
		wait(2)
		Character.Head.face.Texture = "rbxassetid://269748407"
		CreateSound("633394595", hed, 10, 1)
		wait(2)
		Character.Head.face.Texture = "rbxassetid://494811799"
		STHAP:play()
		wait(11)
		forevergone:play()
	end

	function OBJECTION()
		attack = true
		hum.WalkSpeed = 10
		Character.Head.face.Texture = "rbxassetid://55831869"
		CreateSound("330859085", hed, 10, 1)
		for i = 0,8,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(0), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function Hello()
		attack = true
		hum.WalkSpeed = 10
		Character.Head.face.Texture = "rbxassetid://334668738"
		CreateSound("855338765", hed, 10, 0.9)
		for i = 0,3,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function Victory()
		attack = true
		hum.WalkSpeed = 1.01
		Character.Head.face.Texture = "rbxassetid://616284160"
		Humanoid.Jump = true
		CreateSound("130834939", hed, 10, 1)
		for i = 0,3.7,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
		end
		Humanoid.Jump = true
		for i = 0,3.7,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-180), Rad(-25), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
		end
		Humanoid.Jump = true
		for i = 0,3.7,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
		end
		Humanoid.Jump = true
		for i = 0,3.7,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-180), Rad(-25), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
		end
		Humanoid.Jump = true
		for i = 0,3.7,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function ShutTheHellUp()
		attack = true
		hum.WalkSpeed = 2.01
		Character.Head.face.Texture = "rbxassetid://963148419"
		CreateSound("336377340", hed, 10, 1)
		for i = 0,3,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		end
		for i = 0,1.2,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		end
		for i = 0,1.2,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-5), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		end
		for i = 0,1.2,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		end
		for i = 0,1.2,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-5), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		end
		for i = 0,2,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(120), Rad(0), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		end
		for i = 0,2,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		end
		hum.WalkSpeed = 16
		Character.Head.face.Texture = "rbxassetid://620619801"
		attack = false
	end

	function SpinMeDad() --YOU SPIN ME RIGHT ROUND BABY RIGHT ROUND
		attack = true
		hum.WalkSpeed = 5
		Humanoid.JumpPower = 175
		Character.Head.face.Texture = "rbxassetid://1223903433"
		CreateSound("145799973", hed, 10, 1)
		local vel2 = Instance.new("BodyVelocity",tors)
		vel2.Velocity = Vector3.new(0,1.2,0)
		vel2.MaxForce = Vector3.new(10000000,10000000,10000000)
		for i = 0,60,0.1 do
			HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 5, 20, 53, "Knockdown")
			swait()
			CameraEnshaking(1, 1)
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0-255.45*i)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(90)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-90)), 0.1)
		end
		hum.WalkSpeed = 16
		vel2:Destroy()
		Character.Head.face.Texture = "rbxassetid://620619801"
		Humanoid.JumpPower = 50
		attack = false
	end

	function EndMySufferingV2() --why
		attack = true
		hum.WalkSpeed = 1.01
		Character.Head.face.Texture = "rbxassetid://202210455"
		local A = math.random(1,5)
		if A == 1 then
			meme.SoundId = "rbxassetid://295810519"
		end
		if A == 2 then
			meme.SoundId = "rbxassetid://1124778077"
		end
		if A == 3 then
			meme.SoundId = "rbxassetid://464157070"
		end
		if A == 4 then
			meme.SoundId = "rbxassetid://146334595"
		end
		if A == 5 then
			meme.SoundId = "rbxassetid://145536915"
		end
		meme:Play()
		bass:Play()
		joyemoji.Rate = 70
		LIT.Rate = 70
		ok.Rate = 70
		toast.Rate = 70

		for i = 0,50,0.1 do
			swait()
			CameraEnshaking(1, 10)
			bass.Parent = hed
			meme.Parent = hed
			rootj.C0=clerp(rootj.C0,RootCF*CF(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(15),math.rad(-10),math.rad(0)),0.15)
			tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(35),math.rad(0),math.rad(0)),.3)
			RH.C0=clerp(RH.C0,CF(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
			LH.C0=clerp(LH.C0,CF(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-20)),0.15)
			RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5+0.1*math.sin(sine/30), -0.6) * angles(math.rad(-0), math.rad(10), math.rad(-110)), 0.1)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-10), math.rad(-105)), 0.1)
		end
		bass:Stop()
		meme:Stop()
		joyemoji.Rate = 0
		LIT.Rate = 0
		ok.Rate = 0
		toast.Rate = 0
		Character.Head.face.Texture = "rbxassetid://620619801"
		attack = false
		hum.WalkSpeed = 16
	end

	function HELP()
		attack = true
		hum.WalkSpeed = 1.01
		Character.Head.face.Texture = "rbxassetid://307972876"
		CreateSound("1123321019", hed, 10, 1)
		for i = 0,15,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		end
		CreateSound("198462271", hed, 10, 1)
		for i = 0,8,0.1 do
			Character.Head.face.Texture = "rbxassetid://341497730"
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		end
		for i = 0,8,0.1 do
			Character.Head.face.Texture = "rbxassetid://341497730"
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(60), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		end
		CreateSound("948494432", hed, 10, 1)
		for i = 0,7.5,0.1 do
			Character.Head.face.Texture = "rbxassetid://249062487"
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(60), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		end
		CreateSound("1542642349", hed, 10, 1)
		for i = 0,10,0.1 do
			Character.Head.face.Texture = "rbxassetid://270636807"
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		end
		CreateSound("269597232", hed, 10, 1)
		for i = 0,6,0.1 do
			Character.Head.face.Texture = "rbxassetid://265057155"
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function Choose()
		attack = true
		hum.WalkSpeed = 1.01
		Character.Head.face.Texture = "rbxassetid://374187112"
		CreateSound("130784263", hed, 10, 1)
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
		end
		for i = 0,5,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(-10)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(10)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function slap()
		attack = true
		hum.WalkSpeed = 10
		CreateSound("146163534", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://293603561"
		game.Players.LocalPlayer.Character.Humanoid:TakeDamage(7)
		CameraEnshaking(1, 2)
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(115 + 4), Rad(45), Rad(50)), 0.1)
		end
		Character.Head.face.Texture = "rbxassetid://620619801"
		attack = false
		hum.WalkSpeed = 16
	end

	function MYSPAGHETTTTTTT() --ow
		attack = true
		hum.WalkSpeed = 1.01
		CreateSound("1282149571", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://1329282756"
		game.Players.LocalPlayer.Character.Humanoid:TakeDamage(10)
		CameraEnshaking(1, 2.2)
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(5)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(115 + 4), Rad(45), Rad(50)), 0.1)
		end
		for i = 0,5,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
		end
		for i = 0,6,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(-10)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(10)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end


	function dead()
		attack = true
		hum.WalkSpeed = 0.20
		CreateSound("137225991", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://297512410"
		for i = 0,1.1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
		end
		for i = 0,1.1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(90), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
		end
		for i = 0,1.1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(180), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
		end
		for i = 0,1.1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(270), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
		end
		for i = 0,1.1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
		end
		for i = 0,1.1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(90), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
		end
		for i = 0,1.1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(180), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
		end
		for i = 0,1.1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(270), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
		end
		for i = 0,1.1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
		end
		Character.Head.face.Texture = "rbxassetid://273309187"
		for i = 0,9,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -2.59 + 0.1) * angles(Rad(-90), Rad(90), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(30)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-30)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function hap() --much hap
		attack = true
		hum.WalkSpeed = 0.10
		CreateSound("363808674", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://315792941"
		for i = 0,12,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(180)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
		end
		CreateSound("233168827", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://335761015"
		for i = 0,10,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(180)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
		end
		CreateSound("363808674", hed, 10, 1)
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function HAAAAA() --KONO POWA
		attack = true
		hum.WalkSpeed = 1.01
		Character.Head.face.Texture = "rbxassetid://305068389"
		chargeup.Pitch = 1
		for i = 0,7,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
		end
		Character.Head.face.Texture = "rbxassetid://313921371"
		chargeup:play()
		for i = 0,30,0.1 do
			swait()
			CameraEnshaking(1, 2)
			chargeup.Parent = hed
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
		end
		chargeup:stop()
		chargeup.Pitch = 1.1
		chargeup.TimePosition = 1
		chargeup:play()
		Character.Head.face.Texture = "rbxassetid://304942859"
		for i, v in pairs(c:children()) do
			if v.ClassName == "Part" then
				local tra = trazx:clone()
				tra.Parent = v
				tra.LightEmission = 1
				tra.Color = ColorSequence.new(Color3.new(0, 0.6666666666666666, 1))
				tra.Rate = 15
				tra.Rotation = NumberRange.new(-5, 5)
				tra.Lifetime = NumberRange.new(1.5, 2)
				tra.Size = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 0.1, 0),
					NumberSequenceKeypoint.new(1, 0, 0)
				})
				tra.Transparency = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 1, 0),
					NumberSequenceKeypoint.new(0.135, 0, 0),
					NumberSequenceKeypoint.new(0.875, 0, 0),
					NumberSequenceKeypoint.new(1, 1, 0)
				})
				tra.Speed = NumberRange.new(0.5)
				tra.VelocitySpread = 360
				tra.VelocityInheritance = 0.5
				tra.ZOffset = 2
				tra.Acceleration = Vector3.new(0, 2.5, 0)
			end
		end
		local tra = trazx:clone()
		tra.Parent = c.HumanoidRootPart
		tra.Texture = "rbxassetid://347730682"
		tra.LightEmission = 0.8
		tra.Color = ColorSequence.new(Color3.new(0, 0.6666666666666666, 1))
		tra.Rate = 250
		tra.Rotation = NumberRange.new(-5, 5)
		tra.Lifetime = NumberRange.new(0.75)
		tra.Size = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 4.81, 0.875),
			NumberSequenceKeypoint.new(1, 2.13, 0.875)
		})
		tra.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 1, 0),
			NumberSequenceKeypoint.new(0.0399, 0.85, 0),
			NumberSequenceKeypoint.new(0.394, 0.9, 0),
			NumberSequenceKeypoint.new(0.699, 1, 0),
			NumberSequenceKeypoint.new(1, 1, 0)
		})
		tra.Speed = NumberRange.new(15)
		tra.VelocitySpread = 360
		tra.VelocityInheritance = 0.5
		tra.ZOffset = 3.5
		tra.Acceleration = Vector3.new(0, 25, 0)
		for i = 0,35,0.1 do
			swait()
			ohno.Parent = hed
			CameraEnshaking(1, 3)
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(60), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
		end
		chargeup:stop()
		chargeup.Pitch = 1.3
		chargeup.TimePosition = 1
		chargeup:play()
		tra:Destroy()
		tra:Destroy()
		Character.Head.face.Texture = "rbxassetid://280233855"
		local tra = trazx:clone()
		tra.Parent = c.HumanoidRootPart
		tra.Texture = "rbxassetid://347730682"
		tra.LightEmission = 0.8
		tra.Color = ColorSequence.new(Color3.new(1, 0, 0))
		tra.Rate = 250
		tra.Rotation = NumberRange.new(-5, 5)
		tra.Lifetime = NumberRange.new(0.3)
		tra.Size = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 8, 0.875),
			NumberSequenceKeypoint.new(1, 10, 0.875)
		})
		tra.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 1, 0),
			NumberSequenceKeypoint.new(0.0399, 0.531, 0),
			NumberSequenceKeypoint.new(0.394, 0.906, 0),
			NumberSequenceKeypoint.new(0.699, 1, 0),
			NumberSequenceKeypoint.new(1, 1, 0)
		})
		for i = 0,32,0.1 do
			swait()
			CameraEnshaking(1, 5)
			chargeup.Parent = hed
			game.Players.LocalPlayer.Character.Humanoid:TakeDamage(0.12)
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-65), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
		end
		chargeup:stop()
		CreateSound("681582832", hed, 10, 1)
		game.Players.LocalPlayer.Character:BreakJoints()
		local S = Instance.new("Explosion",workspace)    
		S.Position = tors.Position
		S.BlastPressure = 9
		S.BlastRadius = 30
		S.ExplosionType = 0
		attack = false
		hum.WalkSpeed = 16
		Character.Head.face.Texture = "rbxassetid://295197013"
		tra:Destroy()
		CameraEnshaking(4, 30)
		error("WARNING, TO MUCH ENERGY.")
	end

	function NEN()
		attack = true
		hum.WalkSpeed = 1.01
		CreateSound("230292011", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://705269463"
		for i = 0,4,0.1 do
			swait()
			CameraEnshaking(1, 3)
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-90), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function FLYSKYHIGH()
		attack = true
		timetofly = false
		hum.WalkSpeed = 0.05
		Character.Head.face.Texture = "rbxassetid://705269463"
		Cause_Im_having_a_good_time_having_a_good_time:Play()
		Cause_Im_having_a_good_time_having_a_good_time.TimePosition = 35.3
		Humanoid.JumpPower = 0
		for i = 0,300,0.1 do --thatsalongtime
			swait()
			CameraEnshaking(1, 7)
			HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 75, 500, 100, "Knockdown")
			Cause_Im_having_a_good_time_having_a_good_time.Parent = hed
			root.Velocity = root.CFrame.lookVector * 225
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0-255.45*i), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0-255.45*i)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0-255.45*i)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-75), Rad(0), Rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-75), Rad(0), Rad(0)), 0.1)
		end
		Cause_Im_having_a_good_time_having_a_good_time:Stop()
		attack = false
		Humanoid.JumpPower = 50
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
		wait(45)
		timetofly = true
		warn("You can FLY SKY HIGH Now! Go Nuts!") --please dont go nuts
	end


	function highnoon()
		attack = true
		hum.WalkSpeed = 1.01
		CreateSound("495316660", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://155195214"
		CameraEnshaking(2, 4)
		local Blobby = Instance.new("Part", char)
		Blobby.Name = "Blob"
		Blobby.CanCollide = false
		Blobby.BrickColor = BrickColor.new("Really black")
		Blobby.Transparency = 0
		Blobby.Material = "Plastic"
		Blobby.Size = Vector3.new(1, 1, 2)
		Blobby.TopSurface = Enum.SurfaceType.Smooth
		Blobby.BottomSurface = Enum.SurfaceType.Smooth

		local Weld = Instance.new("Weld", Blobby)
		Weld.Part0 = ra
		Weld.Part1 = Blobby
		Weld.C1 = CFrame.new(0, -.4, -1.6) *angles(Rad(180), Rad(0), Rad(180))
		Weld.C0 = CFrame.Angles(math.rad(-90),0,0)

		local M2 = Instance.new("SpecialMesh")
		M2.Parent = Blobby
		M2.MeshId = "http://www.roblox.com/asset/?id=432256490"
		M2.TextureId = "http://www.roblox.com/asset/?id=432256526"
		M2.Scale = Vector3.new(.002, .002, .002)
		for i = 0,7.75,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(90)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.2)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-.6), Rad(180)), 0.2)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-45), Rad(-.6), Rad(136 - 4.5 * Sin(sine / 20))), 0.2)
		end
		for i = 0,16.5,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(90)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.2)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-.6), Rad(90)), 0.2)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-45), Rad(-.6), Rad(136 - 4.5 * Sin(sine / 20))), 0.2)
		end
		Blobby.Transparency = 1
		Blobby:Destroy()
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function somuchcancerwhy() --o no
		attack = true
		hum.WalkSpeed = 0.10
		Character.Head.face.Texture = "rbxassetid://315074049"
		local A = math.random(1,13)
		if A == 1 then
			ohno.SoundId = "rbxassetid://295810519"
			ohno.TimePosition = 1
		end
		if A == 2 then
			ohno.SoundId = "rbxassetid://488472970"
			ohno.TimePosition = 2
		end
		if A == 3 then
			ohno.SoundId = "rbxassetid://917045199"
			ohno.TimePosition = 3
		end
		if A == 4 then
			ohno.SoundId = "rbxassetid://324205173"
			ohno.TimePosition = 1
		end
		if A == 5 then
			ohno.SoundId = "rbxassetid://376134741"
			ohno.TimePosition = 8
		end
		if A == 6 then
			ohno.SoundId = "rbxassetid://164147183"
			ohno.TimePosition = 0
		end
		if A == 7 then
			ohno.SoundId = "rbxassetid://825526716"
			ohno.TimePosition = 1
		end
		if A == 8 then
			ohno.SoundId = "rbxassetid://185460366"
			ohno.TimePosition = 0
		end
		if A == 9 then
			ohno.SoundId = "rbxassetid://273319633"
			ohno.TimePosition = 1
		end
		if A == 10 then
			ohno.SoundId = "rbxassetid://506212392"
			ohno.TimePosition = 2
		end
		if A == 11 then
			ohno.SoundId = "rbxassetid://708297448"
			ohno.TimePosition = 4
		end
		if A == 12 then
			ohno.SoundId = "rbxassetid://497199103"
			ohno.TimePosition = 9
		end
		if A == 13 then
			ohno.SoundId = "rbxassetid://152833989"
			ohno.TimePosition = 1
		end
		ohno:Play()
		for i = 0,100,0.1 do
			swait()
			CameraEnshaking(2, 3)
			ohno.Parent = hed
			char.Torso.Neck.C0 = char.Torso.Neck.C0 * CFrame.Angles(math.random(-10,10),math.random(-10,10),math.random(-10,10))
		end
		attack = false
		ohno:Stop()
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function WRY() --WRYYYYYYY
		attack = true
		hum.WalkSpeed = 0.30
		CreateSound("794081034", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://396389196"
		for i = 0,2,0.1 do
			swait()
			CameraEnshaking(1, 2)
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(140), Rad(60)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-140), Rad(-60)), 0.1)
		end
		for i = 0,14.7,0.1 do
			swait()
			CameraEnshaking(1, 3)
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 1, -1 + 0.1) * angles(Rad(-75), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(65), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-70)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(70)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(45), Rad(0), Rad(40)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(45), Rad(-0), Rad(-40)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function BOI()
		attack = true
		hum.WalkSpeed = 1.01
		CreateSound("390901873", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://282463320"
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(50), Rad(90)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-50), Rad(-90)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(140), Rad(60)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-140), Rad(-60)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function WhatHuh()
		attack = true
		hum.WalkSpeed = 1.01
		CreateSound("130766865", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://276732672"
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(26), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
		end
		for i = 0,6.7,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(-26), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
		end
		for i = 0,8.1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(26), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
		end
		for i = 0,1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(40), Rad(-26), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
		end
		for i = 0,1,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(40), Rad(26), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(-26), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function NothingPersonal()
		if mouse.Target.Parent ~= char and mouse.Target.Parent.Parent ~= char and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			local HITBODY = mouse.Target.Parent
			local TORS = HITBODY:FindFirstChild("Torso") or HITBODY:FindFirstChild("UpperTorso")
			local HEAD = HITBODY:FindFirstChild("Head")
			local HUMAN = mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
			if TORS ~= nil and HUMAN ~= nil then
				attack = true
				root.CFrame = TORS.CFrame * CFrame.new(-1,0,3)
				TORS.Anchored = true
				hum.WalkSpeed = 0
				Character.Head.face.Texture = "rbxassetid://40770311"
				CreateSound("1255922819", hed, 10, 1)
				CameraEnshaking(2, 4)
			end
			wait(3.5)
			for i = 0,9,0.1 do
				swait()
				for i = 1,2 do
					HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 1, 10, 53, "Knockdown")
					CameraEnshaking(1, 7)
					Effects.Sphere.Create(BrickColor.new("Persimmon"), TORS.CFrame*CFrame.new(math.random(-200,200)/100,math.random(-300,200)/100,math.random(-100,100)/100), 1, 1, 1, 15, 15, 15, 0.2)
				end
			end
			wait(.5)
			TORS.Anchored = false
			attack = false
			Character.Head.face.Texture = "rbxassetid://620619801"
			hum.WalkSpeed = 16
		end
	end

	function VeryMuchWorrying()
		attack = true
		hum.WalkSpeed = 1.01
		Character.Head.face.Texture = "rbxassetid://111523405"
		CreateSound("1395854043", hed, 10, 1)
		for i = 0,14,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-145)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(145)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function Ashes() --Straight from... Whatever it was called.
		attack = true
		hum.WalkSpeed = 1.01
		Character.Head.face.Texture = "rbxassetid://360687027"
		CreateSound("290084602", tors, 10, 1)
		for i = 0,6.2,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-30), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-5), Rad(0), Rad(-0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-0), Rad(0), Rad(145)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-0), Rad(0), Rad(-145)), 0.1)
		end
		for i = 0,6.2,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-5), Rad(0), Rad(-20)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-30), Rad(0), Rad(15)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-30), Rad(0), Rad(-15)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function AnotherOne() --WhAT ANOTHER ONE
		attack = true
		hum.WalkSpeed = 1.01
		local icri = CreateSound("1205111204", hed, 10, 1)
		swait(165)
		local FRAME = tors.CFrame
		repeat
			swait()
			Character.Head.face.Texture = "rbxassetid://582931093"
			CameraEnshaking(1, 10)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(90)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-90)), 0.1)
			tors.CFrame = FRAME * CF(0,1,0)
			swait()
			tors.CFrame = FRAME
		until icri.Playing == false
		Character.Head.face.Texture = "rbxassetid://620619801"
		attack = false
		hum.WalkSpeed = 16
	end

	function Dance()
		attack = true
		hum.WalkSpeed = 1.01
		CreateSound("838766490", hed, 10, 1)
		Character.Head.face.Texture = "rbxassetid://258591579"
		for i = 0,2,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,4,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
		end
		for i = 0,3,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
		end
		attack = false
		Character.Head.face.Texture = "rbxassetid://620619801"
		hum.WalkSpeed = 16
	end

	function kyu_will_break_your_neck_asdf_longest_function_name_ever_xd()
		attack = true
		Character.Head.face.Texture = "rbxassetid://266304560"
		for i = 0,6,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.2 * Cos(sine / 20)) * angles(Rad(170), Rad(0), Rad(-15)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.3, 0.8 + 0.05 * Sin(sine / 30), -0.025 * Cos(sine / 20)) * angles(Rad(140), Rad(0), Rad(15)), 0.1)
		end
		CreateSound("1093102664", hed, 10, 1)
		CameraEnshaking(3, 8)
		for i = 0,2,0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(5), Rad(0), Rad(0)), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(10), Rad(40), Rad(0)), 0.4)
			RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
			RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.2 * Cos(sine / 20)) * angles(Rad(200), Rad(0), Rad(-40)), 0.4)
			LW.C0 = clerp(LW.C0, CF(-1.3, 0.8 + 0.05 * Sin(sine / 30), -0.025 * Cos(sine / 20)) * angles(Rad(40), Rad(0), Rad(40)), 0.4)
		end
		Character.Head.face.Texture = "rbxassetid://30128383"
		hum.MaxHealth = 0
		ragdoll(char)
		CreateSound("534269232", hed, 5, 1)
		error("Seems like you just died.")
	end

	MoreTaunts = false
	mouse.KeyDown:connect(function(key)
		if attack == false then
			if MoreTaunts == false then
				if key == 'q' then
					GEtOuT()
				elseif key == 'e' then
					GEtOuT2()
				elseif key == 'x' then
					OBJECTION()
				elseif key == 'n' then
					BOI()
				elseif key == 'u' then
					Victory()
				elseif key == '3' then
					hap()
				elseif key == '6' then
					Flight()
				elseif key == '9' and timetofly then
					FLYSKYHIGH()
				elseif key == '9' then
					local A = math.random(1,10)
					if A == 1 then
						warn ("This has a Cooldown, Please wait. :>")
					end
					if A == 2 then
						warn ("You can't Fly All day, you know.")
					end
					if A == 3 then
						warn ("Calm down there.")
					end
					if A == 4 then
						warn ("Take a Break.")
					end
					if A == 5 then
						warn ("*Elevator Music plays in the backround*")
					end
					if A == 6 then
						warn ("I know, You want to FLY SKY HIGH, but wait a little bit.")
					end
					if A == 7 then
						warn ("Can you wait a LITTLE Longer?")
					end
					if A == 8 then
						warn ("Like a tiger defying the laws of gravity...")
					end
					if A == 9 then
						warn ("DON'T STOP ME NNNNNOOOOOOOOWWWW")
					end
					if A == 10 then
						warn ("Oh, I'm burnin' through the sky, Yeah!")
					end
				elseif key == 'k' then
					Hello()
				elseif key == '5' then
					HAAAAA()
				elseif key == '4' then
					Dance()
				elseif key == '1' then
					HELP()
				elseif key == '2' then
					dead()
				elseif key == 'j' then
					WhatHuh()
				elseif key == 'l' then
					ShutTheHellUp()
				elseif key == 'c' then
					Choose()
				elseif key == 'r' then
					MYSPAGHETTTTTTT()
				elseif key == 't' then
					SpinMeDad()
				elseif key == 'y' then
					EndMySufferingV2()
				elseif key == 'f' then
					NEN()
				elseif key == 'z' then
					NothingPersonal()
				elseif key == '7' then
					somuchcancerwhy()
				elseif key == '8' then
					highnoon()
				elseif key == 'v' then
					VeryMuchWorrying()
				elseif key == 'b' then
					Ashes()
				elseif key == 'p' then
					kyu_will_break_your_neck_asdf_longest_function_name_ever_xd()
				elseif key == 'g' then
					AnotherOne()
				elseif key == 'h' then
					slap()
				elseif key == 'm' then
					WRY()
				end
			end
		end
	end)

	-------------------------------------------------------
	--End Attacks N Stuff--
	-------------------------------------------------------




	while jumping do
		Humanoid.Jump = true
		wait(0.9)
	end




	-------------------------------------------------------
	--Start Animations--
	-------------------------------------------------------
	local equipped = false
	local idle = 0
	local change = 1
	local val = 0
	local toim = 0
	local idleanim = 0.4
	hum.Animator.Parent = nil
	while true do
		swait()
		sine = sine + change
		local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
		local velderp = root.Velocity.y
		hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4, char)
		if equipped == true or equipped == false then
			if attack == false then
				idle = idle + 1
			else
				idle = 0
			end
			if 1 < root.Velocity.y and hitfloor == nil then
				Anim = "Jump"
				if attack == false then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.3)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-40), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
					LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
					LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -0.3) * LHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
					RH.C0 = clerp(RH.C0, CF(1, -1, 0.3) * angles(Rad(0), Rad(90), Rad(-20)), 0.3)
				end
			elseif -1 > root.Velocity.y and hitfloor == nil then
				Anim = "Fall"
				if attack == false then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-5), Rad(0), Rad(0)), 0.3)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(40), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
					LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
					LH.C0=clerp(LH.C0, CF(-1,-.4-0.1 * Cos(sine / 20), -.6) * LHCF * angles(Rad(-5), Rad(-0), Rad(20)), 0.15)
					RH.C0=clerp(RH.C0, CF(1,-.3-0.1 * Cos(sine / 20), -.6) * angles(Rad(0), Rad(90), Rad(-20)), .3)
				end
			elseif torvel < 1 and hitfloor ~= nil then
				Anim = "Idle"
				change = 1
				if attack == false then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
					RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(30 * Cos(sine / 20)), Rad(0), Rad(5)), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(30 * Cos(sine / 20)), Rad(0), Rad(-5)), 0.1)
				end
			elseif tors.Velocity.magnitude < 50 and hitfloor ~= nil then
				Anim = "Walk"
				change = 1
				if attack == false then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7) * angles(Rad(9-2.5 * Cos(sine / 3.5)), Rad(0), Rad(10 * Cos(sine / 7))), 0.15)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(sine / 7) / 2, 0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 - 35 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 2 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(sine / 7) / 2, -0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 + 35 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(70) * Cos(sine / 7) , Rad(0), Rad(5)), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-70) * Cos(sine / 7) , Rad(0),	Rad(-5)), 0.1)
				end
			end
		end
		if 0 < #Effects then
			for e = 1, #Effects do
				if Effects[e] ~= nil then
					local Thing = Effects[e]
					if Thing ~= nil then
						local Part = Thing[1]
						local Mode = Thing[2]
						local Delay = Thing[3]
						local IncX = Thing[4]
						local IncY = Thing[5]
						local IncZ = Thing[6]
						if 1 >= Thing[1].Transparency then
							if Thing[2] == "Block1" then
								Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Block2" then
								Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
								local Mesh = Thing[7]
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Block3" then
								Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
								local Mesh = Thing[7]
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Cylinder" then
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Blood" then
								local Mesh = Thing[7]
								Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Elec" then
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Disappear" then
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Shatter" then
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
								Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
								Thing[6] = Thing[6] + Thing[5]
							end
						else
							Part.Parent = nil
							table.remove(Effects, e)
						end
					end
				end
			end
		end
	end
	-------------------------------------------------------
	--End Animations And Script--
	-------------------------------------------------------

	--cool beans boibiparti
end)

snas.Name = "snas"
snas.Parent = Frame
snas.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
snas.Position = UDim2.new(0.409388185, 0, 0.724017024, 0)
snas.Size = UDim2.new(0, 106, 0, 44)
snas.Font = Enum.Font.SourceSans
snas.Text = "Sans"
snas.TextColor3 = Color3.fromRGB(0, 0, 0)
snas.TextSize = 20.000
snas.MouseButton1Down:connect(function()
	-- Created by Nebula_Zorua --
	-- Sans Curse (A Curse of Light) --
	-- Custom Arcane Adventures Magic --
	-- Wielder: Everybody (Released) --
	-- Why the fuck did I make this --
	-- I don't even LIKE undertale --
	-- what the fuck --

	-- Discord: Nebula the Zorua#6969
	-- Youtube: https://www.youtube.com/channel/UCo9oU9dCw8jnuVLuy4_SATA

	-- You can change the Magic Circle n stuff down under Customization, at MagicVariant --


	--// Shortcut Variables \\--
	local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
	local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
	local C3 = {N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
	local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
	local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
	local R3 = {N=Region3.new}
	local De = S.Debris
	local WS = workspace
	local Lght = S.Lighting
	local RepS = S.ReplicatedStorage
	local IN = Instance.new
	local Plrs = S.Players

	local Emit = IN("ParticleEmitter").Emit;

	--// Initializing \\--
	local Plr = Plrs.LocalPlayer
	local Char = Plr.Character
	local Hum = Char:FindFirstChildOfClass'Humanoid'
	local RArm = Char["Right Arm"]
	local LArm = Char["Left Arm"]
	local RLeg = Char["Right Leg"]
	local LLeg = Char["Left Leg"]	
	local Root = Char:FindFirstChild'HumanoidRootPart'
	local Torso = Char.Torso
	local Head = Char.Head
	local NeutralAnims = true
	local Attack = false
	local Debounces = {Debounces={}}
	local Mouse = Plr:GetMouse()
	local Hit = {}
	local Sine = 0
	local Change = 1

	local Effects = IN("Folder",Char)
	Effects.Name = "Effects"


	--// Debounce System \\--


	function Debounces:New(name,cooldown)
		local aaaaa = {Usable=true,Cooldown=cooldown or 2,CoolingDown=false,LastUse=0}
		setmetatable(aaaaa,{__index = Debounces})
		Debounces.Debounces[name] = aaaaa
		return aaaaa
	end

	function Debounces:Use(overrideUsable)
		assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
		if(self.Usable or overrideUsable)then
			self.Usable = false
			self.CoolingDown = true
			local LastUse = time()
			self.LastUse = LastUse
			delay(self.Cooldown or 2,function()
				if(self.LastUse == LastUse)then
					self.CoolingDown = false
					self.Usable = true
				end
			end)
		end
	end

	function Debounces:Get(name)
		assert(typeof(name) == 'string',("bad argument #1 to 'get' (string expected, got %s)"):format(typeof(name) == nil and "no value" or typeof(name)))
		for i,v in next, Debounces.Debounces do
			if(i == name)then
				return v;
			end
		end
	end

	function Debounces:GetProgressPercentage()
		assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
		if(self.CoolingDown and not self.Usable)then
			return math.max(
				math.floor(
					(
						(time()-self.LastUse)/self.Cooldown or 2
					)*100
				)
			)
		else
			return 100
		end
	end

	--// Instance Creation Functions \\--

	function Sound(parent,id,pitch,volume,looped,effect,autoPlay)
		local Sound = IN("Sound")
		Sound.SoundId = "rbxassetid://".. tostring(id or 0)
		Sound.Pitch = pitch or 1
		Sound.Volume = volume or 1
		Sound.Looped = looped or false
		if(autoPlay)then
			coroutine.wrap(function()
				repeat wait() until Sound.IsLoaded
				Sound.Playing = autoPlay or false
			end)()
		end
		if(not looped and effect)then
			Sound.Stopped:connect(function()
				Sound.Volume = 0
				Sound:destroy()
			end)
		elseif(effect)then
			warn("Sound can't be looped and a sound effect!")
		end
		Sound.Parent =parent or Torso
		return Sound
	end
	function Part(parent,color,material,size,cframe,anchored,cancollide)
		local part = IN("Part")
		part.Parent = parent or Char
		part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
		part.Material = material or Enum.Material.SmoothPlastic
		part.TopSurface,part.BottomSurface=10,10
		part.Size = size or V3.N(1,1,1)
		part.CFrame = cframe or CF.N(0,0,0)
		part.CanCollide = cancollide or false
		part.Anchored = anchored or false
		return part
	end

	function Weld(part0,part1,c0,c1)
		local weld = IN("Weld")
		weld.Parent = part0
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C0 = c0 or CF.N()
		weld.C1 = c1 or CF.N()
		return weld
	end

	function Mesh(parent,meshtype,meshid,textid,scale,offset)
		local part = IN("SpecialMesh")
		part.MeshId = meshid or ""
		part.TextureId = textid or ""
		part.Scale = scale or V3.N(1,1,1)
		part.Offset = offset or V3.N(0,0,0)
		part.MeshType = meshtype or Enum.MeshType.Sphere
		part.Parent = parent
		return part
	end

	NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance)
		inst.Parent = parent
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end	
		end
		return inst;
	end

	function Clone(instance,parent,properties)
		local inst = instance:Clone()
		inst.Parent = parent
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end

	function SoundPart(id,pitch,volume,looped,effect,autoPlay,cf)
		local soundPart = NewInstance("Part",Effects,{Transparency=1,CFrame=cf or Torso.CFrame,Anchored=true,CanCollide=false,Size=V3.N()})
		local Sound = IN("Sound")
		Sound.SoundId = "rbxassetid://".. tostring(id or 0)
		Sound.Pitch = pitch or 1
		Sound.Volume = volume or 1
		Sound.Looped = looped or false
		if(autoPlay)then
			coroutine.wrap(function()
				repeat wait() until Sound.IsLoaded
				Sound.Playing = autoPlay or false
			end)()
		end
		if(not looped and effect)then
			Sound.Stopped:connect(function()
				Sound.Volume = 0
				soundPart:destroy()
			end)
		elseif(effect)then
			warn("Sound can't be looped and a sound effect!")
		end
		Sound.Parent = soundPart
		return Sound
	end


	--// Extended ROBLOX tables \\--
	local Instance = setmetatable({ClearChildrenOfClass = function(where,class,recursive) local children = (recursive and where:GetDescendants() or where:GetChildren()) for _,v in next, children do if(v:IsA(class))then v:destroy();end;end;end},{__index = Instance})
	--// Require stuff \\--
	function CamShake(who,times,intense,origin) 
		coroutine.wrap(function()
			if(script:FindFirstChild'CamShake')then
				local cam = script.CamShake:Clone()
				cam:WaitForChild'intensity'.Value = intense
				cam:WaitForChild'times'.Value = times

				if(origin)then NewInstance((typeof(origin) == 'Instance' and "ObjectValue" or typeof(origin) == 'Vector3' and 'Vector3Value'),cam,{Name='origin',Value=origin}) end
				cam.Parent = who
				wait()
				cam.Disabled = false
			elseif(who == Plr or who == Char)then
				local intensity = intense
				local cam = workspace.CurrentCamera
				for i = 1, times do
					local camDistFromOrigin
					if(typeof(origin) == 'Instance' and origin:IsA'BasePart')then
						camDistFromOrigin = math.floor( (cam.CFrame.p-origin.Position).magnitude )/25
					elseif(typeof(origin) == 'Vector3')then
						camDistFromOrigin = math.floor( (cam.CFrame.p-origin).magnitude )/25
					end
					if(camDistFromOrigin)then
						intensity = math.min(intense, math.floor(intense/camDistFromOrigin))
					end
					cam.CFrame = cam.CFrame:lerp(cam.CFrame*CFrame.new(math.random(-intensity,intensity)/100,math.random(-intensity,intensity)/100,math.random(-intensity,intensity)/100)*CFrame.Angles(math.rad(math.random(-intensity,intensity)/100),math.rad(math.random(-intensity,intensity)/100),math.rad(math.random(-intensity,intensity)/100)),.4)
					swait()
				end
			end
		end)()
	end

	function CamShakeAll(times,intense,origin)
		for _,v in next, Plrs:players() do
			CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,times,intense,origin)
		end
	end

	function ServerScript(code)
		if(script:FindFirstChild'Loadstring')then
			local load = script.Loadstring:Clone()
			load:WaitForChild'Sauce'.Value = code
			load.Disabled = false
			load.Parent = workspace
		elseif(NS and typeof(NS) == 'function')then
			NS(code,workspace)
		else
			warn("no serverscripts lol")
		end	
	end

	function RunLocal(where,code)
		ServerScript([[
		wait()
		script.Parent=nil
		if(not _G.Http)then _G.Http = game:service'HttpService' end
		
		local Http = _G.Http or game:service'HttpService'
		
		local source = ]].."[["..code.."]]"..[[
		local link = "https://api.vorth.xyz/R_API/R.UPLOAD/NEW_LOCAL.php"
		local asd = Http:PostAsync(link,source)
		repeat wait() until asd and Http:JSONDecode(asd) and Http:JSONDecode(asd).Result and Http:JSONDecode(asd).Result.Require_ID
		local ID = Http:JSONDecode(asd).Result.Require_ID
		local vs = require(ID).VORTH_SCRIPT
		vs.Parent = game.]]..where:GetFullName()
		)
	end

	--// Customization \\--

	local Frame_Speed = 60;
	local WalkSpeed = 16
	local DamageColor = BrickColor.new'White'

	local MagicCircles = {
		Default = {Color=C3.N(1,1,1),Texture1=0,Texture2=0},
		OrangeWarPheonix = {EffectColor=BrickColor.new'Deep orange'.Color,Color=C3.N(.9,.9,.9),Texture1=623153986,Texture2=623153990},
		BlueWarPheonix = {EffectColor=BrickColor.new'Teal'.Color,Color=C3.N(.9,.9,.9),Texture1=462499935,Texture2=462499970},
		Plasma = {Color=C3.N(0.70588235294118,0,0.8),Texture1=415906687,Texture2=415906702},
		Water = {Color=C3.RGB(33, 84, 185),Texture1=408441330,Texture2=408441353},
		Earth = {Color=C3.RGB(86, 36, 36),Texture1=394253616,Texture2=394253651},
		Wind = {Color=C3.N(.8,.8,.8),Texture1=376006317,Texture2=376006346},
		Poseidon = {Color=C3.RGB(71, 99, 130),Texture1=346727970,Texture2=346727994},
		AetherLightning = {Color=C3.RGB(23, 255, 197),Texture1=348320016,Texture2=348320030},
		Light = {Color=C3.N(1,1,0),Texture1=343192085,Texture2=343192112},
		Fire = {Color=C3.N(1,0,0),EffectColor=BrickColor.new'Bright red'.Color,Texture1=313945544,Texture2=313945673},
		Lightning = {Color=C3.N(0,1,1),Texture1=314842290,Texture2=314842440},
		GasterBlaster = {Color=C3.N(1,1,1),Texture1=331948662,Texture2=331948662}
	}

	local MagicVariant = MagicCircles.GasterBlaster --[[ You can change this for a different element
Example: 

Changing MagicCircles.GasterBlaster to MagicCircles.Light

would make it a Light Element
]]

	--// Stop animations \\--
	for _,v in next, Hum:GetPlayingAnimationTracks() do
		v:Stop();
	end

	pcall(game.Destroy,Char:FindFirstChild'Animate')
	pcall(game.Destroy,Hum:FindFirstChild'Animator')

	--// Joints \\--

	local LS = NewInstance('Motor',Char,{Part0=Torso,Part1=LArm,C0 = CF.N(-1.5,0.5,0),C1 = CF.N(0,.5,0)})
	local RS = NewInstance('Motor',Char,{Part0=Torso,Part1=RArm,C0 = CF.N(1.5,0.5,0),C1 = CF.N(0,.5,0)})
	local NK = NewInstance('Motor',Char,{Part0=Torso,Part1=Head,C0 = CF.N(0,1.5,0)})
	local LH = NewInstance('Motor',Char,{Part0=Torso,Part1=LLeg,C0 = CF.N(-.5,-1,0),C1 = CF.N(0,1,0)})
	local RH = NewInstance('Motor',Char,{Part0=Torso,Part1=RLeg,C0 = CF.N(.5,-1,0),C1 = CF.N(0,1,0)})
	local RJ = NewInstance('Motor',Char,{Part0=Root,Part1=Torso})

	local LSC0 = LS.C0
	local RSC0 = RS.C0
	local NKC0 = NK.C0
	local LHC0 = LH.C0
	local RHC0 = RH.C0
	local RJC0 = RJ.C0

	--// Artificial HB \\--

	local ArtificialHB = IN("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"

	script:WaitForChild("Heartbeat")

	local tf = 0
	local allowframeloss = false
	local tossremainder = false
	local lastframe = tick()
	local frame = 1/Frame_Speed
	ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function swait(num)
		if num == 0 or num == nil then
			ArtificialHB.Event:wait()
		else
			for i = 0, num do
				ArtificialHB.Event:wait()
			end
		end
	end


	--// Effect Function(s) \\--

	function NumSeq(...)
		local tab = {...}
		local Sequence = {}
		for _,v in next, tab do
			table.insert(Sequence,NumberSequenceKeypoint.new(unpack(v)))
		end
		if(tab[#tab][1] ~= 1)then
			local final = tab[#tab]
			table.insert(Sequence,NumberSequenceKeypoint.new(1,final[2],final[3]))
		end
		return NumberSequence.new(Sequence)
	end

	local DefaultRingParticle = IN("ParticleEmitter")
	DefaultRingParticle.Name = 'RingEmit'
	DefaultRingParticle.LightEmission = 1
	DefaultRingParticle.Size = NumSeq({0,0},{.7,6.28},{.8,5.03},{1,2.9})
	DefaultRingParticle.Texture = "rbxassetid://313951123"
	DefaultRingParticle.Transparency = NumberSequence.new(0,1)
	DefaultRingParticle.ZOffset = 1
	DefaultRingParticle.Drag = 0
	DefaultRingParticle.Acceleration = V3.N()
	DefaultRingParticle.LockedToPart = true
	DefaultRingParticle.Enabled = false
	DefaultRingParticle.Lifetime = NumberRange.new(.6,.6)
	DefaultRingParticle.Rate = 5
	DefaultRingParticle.Rotation = NumberRange.new(0,0)
	DefaultRingParticle.RotSpeed = NumberRange.new(0,0)
	DefaultRingParticle.Speed = NumberRange.new(0,0)
	DefaultRingParticle.SpreadAngle = Vector2.new(0,0)

	function MagicCircle(Data)
		local Variant = Data.Variant or MagicCircles.Default;

		local Size = Data.Size or 10;
		local Pos = Data.Pos*CF.A(M.R(-90),M.R(-90),0) or Torso.CFrame*CF.A(M.R(-90),M.R(-90),0);
		local GrowTime = Data.Time or 1;

		local WeldData = Data.Weld or false;


		local Color = Variant.Color or C3.N(.9,.9,.0)

		local CreationParticle = Data.CreationParticle or DefaultRingParticle;


		local Circle = Part(Effects,BrickColor.new'Maroon',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),Pos,true,false)
		local CircleM = NewInstance("BlockMesh",Circle,{Scale=V3.N()})


		local Emitter = DefaultRingParticle:Clone();
		Emitter.Parent = Circle
		Emitter.Color = ColorSequence.new(Variant.Color)

		local Top = IN("Decal",Circle)
		Top.Texture = "rbxassetid://"..Variant.Texture1
		Top.Face = Enum.NormalId.Top

		local Btm = IN("Decal",Circle)
		Btm.Texture = "rbxassetid://"..Variant.Texture2
		Btm.Face = Enum.NormalId.Bottom

		if(WeldData)then
			Circle.Anchored = false
			Weld(WeldData,Circle,Pos,CF.N())
		end
		local GrowFrames = GrowTime * Frame_Speed
		print(GrowFrames)
		--Size*20,0,Size*20
		Circle.Transparency = 1
		local GrownEvent = Instance.new("BindableEvent",Circle)
		coroutine.wrap(function()

			Emit(Emitter,5)
			local End = Size*20
			local grow = End/GrowFrames
			for i = 1, GrowFrames+1 do
				local aa = math.min(CircleM.Scale.x + grow,End)
				if(aa >= End)then break end
				CircleM.Scale = V3.N(aa,0,aa)
				swait()
			end
			CircleM.Scale = V3.N(End,0,End)
			GrownEvent:Fire()

		end)()

		local Table = {
			Circle = Circle,
			Mesh = CircleM,
			Grow = function(size)
				CircleM.Scale = CircleM.Scale + V3.N(size*20,0,size*20)
			end,
			Destroy = function(timer)
				coroutine.wrap(function()
					if(not timer)then timer = 1 end
					Tween(CircleM,{Scale=V3.N(0,0,0)},timer,Enum.EasingStyle.Quad,Enum.EasingDirection.Out)
					Tween(Top,{Transparency=1},timer,Enum.EasingStyle.Quad,Enum.EasingDirection.Out)
					Tween(Btm,{Transparency=1},timer,Enum.EasingStyle.Quad,Enum.EasingDirection.Out)
					S.Debris:AddItem(Circle,timer+1)
				end)()
			end,
			Grown = GrownEvent.Event
		}

		return Table;
	end

	function Bezier(startpos, pos2, pos3, endpos, t)
		local A = startpos:lerp(pos2, t)
		local B  = pos2:lerp(pos3, t)
		local C = pos3:lerp(endpos, t)
		local lerp1 = A:lerp(B, t)
		local lerp2 = B:lerp(C, t)
		local cubic = lerp1:lerp(lerp2, t)
		return cubic
	end

	function SphereFX(duration,color,scale,pos,endScale,increment)
		return Effect{
			Frames=duration,
			Effect='ResizeAndFade',
			Color=color,
			Size=scale,
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=pos,
			FXSettings={
				EndSize=endScale,
				EndIsIncrement=increment
			}
		}
	end

	function BlastFX(duration,color,scale,pos,endScale,increment)
		return Effect{
			Frames=duration,
			Effect='ResizeAndFade',
			Color=color,
			Size=scale,
			Mesh={MeshType=Enum.MeshType.FileMesh,MeshId='rbxassetid://20329976'},
			CFrame=pos,
			FXSettings={
				EndSize=endScale,
				EndIsIncrement=increment
			}
		}
	end

	function BlockFX(duration,color,scale,pos,endScale,increment)
		return Effect{
			Frames=duration,
			Effect='ResizeAndFade',
			Color=color,
			Size=scale,
			CFrame=pos,
			FXSettings={
				EndSize=endScale,
				EndIsIncrement=increment
			}
		}
	end

	function ShootBullet(data)
		--ShootBullet{Size=V3.N(3,3,3),Shape='Ball',Frames=160,Origin=data.Circle.CFrame,Speed=10}
		local Size = data.Size or V3.N(2,2,2)
		local Color = data.Color or MagicVariant.EffectColor or MagicVariant.Color
		local StudsPerFrame = data.Speed or 10
		local Shape = data.Shape or 'Ball'
		local Frames = data.Frames or 160
		local Pos = data.Origin or Torso.CFrame
		local Direction = data.Direction or Mouse.Hit
		local Material = data.Material or Enum.Material.Neon
		local OnHit = data.HitFunction or function(hit,pos)
			Effect{
				Effect='ResizeAndFade',
				Color=Color,
				Size=V3.N(10,10,10),
				Mesh={MeshType=Enum.MeshType.Sphere},
				CFrame=CF.N(pos),
				FXSettings={
					EndSize=V3.N(.05,.05,.05),
					EndIsIncrement=true
				}
			}
			for i = 1, 5 do
				local angles = CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180))
				Effect{
					Effect='Fade',
					Frames=65,
					Size=V3.N(5,5,10),
					CFrame=CF.N(CF.N(pos)*angles*CF.N(0,0,-10).p,pos),
					Mesh = {MeshType=Enum.MeshType.Sphere},
					Material=Enum.Material.Neon,
					Color=Color,
					MoveDirection=CF.N(CF.N(pos)*angles*CF.N(0,0,-50).p,pos).p,
				}	
			end
			AOEDamage(pos,10,15,30,0,'Normal',10,4)
		end	

		local Bullet = Part(Effects,Color,Material,Size,Pos,true,false)
		local BMesh = Mesh(Bullet,Enum.MeshType.Brick,"","",V3.N(1,1,1),V3.N())
		if(Shape == 'Ball')then
			BMesh.MeshType = Enum.MeshType.Sphere
		elseif(Shape == 'Head')then
			BMesh.MeshType = Enum.MeshType.Head
		elseif(Shape == 'Cylinder')then
			BMesh.MeshType = Enum.MeshType.Cylinder
		end

		coroutine.wrap(function()
			for i = 1, Frames+1 do
				local hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame).p,StudsPerFrame)
				if(hit)then
					OnHit(hit,pos,norm,dist)
					break;
				else
					Bullet.CFrame = CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame)
				end
				swait()
			end
			Bullet:destroy()
		end)()

	end

	function Zap(data)
		local sCF,eCF = data.StartCFrame,data.EndCFrame
		assert(sCF,"You need a start CFrame!")
		assert(eCF,"You need an end CFrame!")
		local parts = data.PartCount or 15
		local zapRot = data.ZapRotation or {-5,5}
		local startThick = data.StartSize or 3;
		local endThick = data.EndSize or startThick/2;
		local color = data.Color or BrickColor.new'Electric blue'
		local delay = data.Delay or 35
		local delayInc = data.DelayInc or 0
		local lastLightning;
		local MagZ = (sCF.p - eCF.p).magnitude
		local thick = startThick
		local inc = (startThick/parts)-(endThick/parts)

		for i = 1, parts do
			local pos = sCF.p
			if(lastLightning)then
				pos = lastLightning.CFrame*CF.N(0,0,MagZ/parts/2).p
			end
			delay = delay + delayInc
			local zapPart = Part(Effects,color,Enum.Material.Neon,V3.N(thick,thick,MagZ/parts),CF.N(pos),true,false)
			local posie = CF.N(pos,eCF.p)*CF.N(0,0,MagZ/parts).p+V3.N(M.RNG(unpack(zapRot)),M.RNG(unpack(zapRot)),M.RNG(unpack(zapRot)))
			if(parts == i)then
				local MagZ = (pos-eCF.p).magnitude
				zapPart.Size = V3.N(endThick,endThick,MagZ)
				zapPart.CFrame = CF.N(pos, eCF.p)*CF.N(0,0,-MagZ/2)
				Effect{Effect='ResizeAndFade',Size=V3.N(thick,thick,thick),CFrame=eCF*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),Color=color,Frames=delay*2,FXSettings={EndSize=V3.N(thick*8,thick*8,thick*8)}}
			else
				zapPart.CFrame = CF.N(pos,posie)*CF.N(0,0,MagZ/parts/2)
			end

			lastLightning = zapPart
			Effect{Effect='Fade',Manual=zapPart,Frames=delay}

			thick=thick-inc

		end
	end

	function Zap2(data)
		local Color = data.Color or BrickColor.new'Electric blue'
		local StartPos = data.Start or Torso.Position
		local EndPos = data.End or Mouse.Hit.p
		local SegLength = data.SegL or 2
		local Thicc = data.Thickness or 0.5
		local Fades = data.Fade or 45
		local Parent = data.Parent or Effects
		local MaxD = data.MaxDist or 200
		local Branch = data.Branches or false
		local Material = data.Material or Enum.Material.Neon
		local Raycasts = data.Raycasts or false
		local Offset = data.Offset or {0,360}
		local AddMesh = (data.Mesh == nil and true or data.Mesh)
		if((StartPos-EndPos).magnitude > MaxD)then
			EndPos = CF.N(StartPos,EndPos)*CF.N(0,0,-MaxD).p
		end
		local hit,pos,norm,dist=nil,EndPos,nil,(StartPos-EndPos).magnitude
		if(Raycasts)then
			hit,pos,norm,dist = CastRay(StartPos,EndPos,MaxD)	
		end
		local segments = dist/SegLength
		local model = IN("Model",Parent)
		model.Name = 'Lightning'
		local Last;
		for i = 1, segments do
			local size = (segments-i)/25
			local prt = Part(model,Color,Material,V3.N(Thicc+size,SegLength,Thicc+size),CF.N(),true,false)
			if(AddMesh)then IN("CylinderMesh",prt) end
			if(Last and math.floor(segments) == i)then
				local MagZ = (Last.CFrame*CF.N(0,-SegLength/2,0).p-EndPos).magnitude
				prt.Size = V3.N(Thicc+size,MagZ,Thicc+size)
				prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,EndPos)*CF.A(M.R(90),0,0)*CF.N(0,-MagZ/2,0)	
			elseif(not Last)then
				prt.CFrame = CF.N(StartPos,pos)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)	
			else
				prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,CF.N(pos)*CF.A(M.R(M.RNG(0,360)),M.R(M.RNG(0,360)),M.R(M.RNG(0,360)))*CF.N(0,0,SegLength/3+(segments-i)).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
			end
			Last = prt
			if(Branch)then
				local choice = M.RNG(1,7+((segments-i)*2))
				if(choice == 1)then
					local LastB;
					for i2 = 1,M.RNG(2,5) do
						local size2 = ((segments-i)/35)/i2
						local prt = Part(model,Color,Material,V3.N(Thicc+size2,SegLength,Thicc+size2),CF.N(),true,false)
						if(AddMesh)then IN("CylinderMesh",prt) end
						if(not LastB)then
							prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,Last.CFrame*CF.N(0,-SegLength/2,0)*CF.A(0,0,M.RRNG(0,360))*CF.N(0,Thicc*7,0)*CF.N(0,0,-1).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
						else
							prt.CFrame = CF.N(LastB.CFrame*CF.N(0,-SegLength/2,0).p,LastB.CFrame*CF.N(0,-SegLength/2,0)*CF.A(0,0,M.RRNG(0,360))*CF.N(0,Thicc*7,0)*CF.N(0,0,-1).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
						end
						LastB = prt
					end
				end
			end
		end
		if(Fades > 0)then
			coroutine.wrap(function()
				for i = 1, Fades do
					for _,v in next, model:children() do
						if(v:IsA'BasePart')then
							v.Transparency = (i/Fades)
						end
					end
					swait()
				end
				model:destroy()
			end)()
		else
			S.Debris:AddItem(model,.01)
		end
		return {End=(Last and Last.CFrame*CF.N(0,-Last.Size.Y/2,0).p),Last=Last,Model=model}
	end

	function Tween(obj,props,time,easing,direction,repeats,backwards)
		local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
		local tween = S.TweenService:Create(obj, info, props)

		tween:Play()
	end

	function Effect(data)
		local FX = data.Effect or 'ResizeAndFade'
		local Parent = data.Parent or Effects
		local Color = data.Color or C3.N(0,0,0)
		local Size = data.Size or V3.N(1,1,1)
		local MoveDir = data.MoveDirection or nil
		local MeshData = data.Mesh or nil
		local SndData = data.Sound or nil
		local Frames = data.Frames or 45
		local Manual = data.Manual or nil
		local Material = data.Material or Enum.Material.Neon
		local CFra = data.CFrame or Torso.CFrame
		local Settings = data.FXSettings or {}
		local Shape = data.Shape or Enum.PartType.Block
		local Snd,Prt,Msh;
		coroutine.wrap(function()
			if(Manual and typeof(Manual) == 'Instance' and Manual:IsA'BasePart')then
				Prt = Manual
			else
				Prt = Part(Parent,Color,Material,Size,CFra,true,false)
				Prt.Shape = Shape
			end
			if(typeof(MeshData) == 'table')then
				Msh = Mesh(Prt,MeshData.MeshType,MeshData.MeshId,MeshData.TextureId,MeshData.Scale,MeshData.Offset)
			elseif(typeof(MeshData) == 'Instance')then
				Msh = MeshData:Clone()
				Msh.Parent = Prt
			elseif(Shape == Enum.PartType.Block)then
				Msh = Mesh(Prt,Enum.MeshType.Brick)
			end
			if(typeof(SndData) == 'table')then
				Snd = Sound(Prt,SndData.SoundId,SndData.Pitch,SndData.Volume,false,false,true)
			elseif(typeof(SndData) == 'Instance')then
				Snd = SndData
			end
			if(Snd)then
				repeat swait() until Snd.Playing and Snd.IsLoaded and Snd.TimeLength > 0
				Frames = Snd.TimeLength * Frame_Speed/Snd.Pitch
			end
			Size = (Msh and Msh.Scale or Size)
			local grow = Size-(Settings.EndSize or (Msh and Msh.Scale or Size)/2)

			local MoveSpeed = nil;
			if(MoveDir)then
				MoveSpeed = (CFra.p - MoveDir).magnitude/Frames
			end
			if(FX ~= 'Arc')then
				for Frame = 1, Frames do
					if(FX == "Fade")then
						Prt.Transparency  = (Frame/Frames)
					elseif(FX == "Resize")then
						if(not Settings.EndSize)then
							Settings.EndSize = V3.N(0,0,0)
						end
						if(Settings.EndIsIncrement)then
							if(Msh)then
								Msh.Scale = Msh.Scale + Settings.EndSize
							else
								Prt.Size = Prt.Size + Settings.EndSize
							end					
						else
							if(Msh)then
								Msh.Scale = Msh.Scale - grow/Frames
							else
								Prt.Size = Prt.Size - grow/Frames
							end
						end 
					elseif(FX == "ResizeAndFade")then
						if(not Settings.EndSize)then
							Settings.EndSize = V3.N(0,0,0)
						end
						if(Settings.EndIsIncrement)then
							if(Msh)then
								Msh.Scale = Msh.Scale + Settings.EndSize
							else
								Prt.Size = Prt.Size + Settings.EndSize
							end					
						else
							if(Msh)then
								Msh.Scale = Msh.Scale - grow/Frames
							else
								Prt.Size = Prt.Size - grow/Frames
							end
						end 
						Prt.Transparency = (Frame/Frames)
					end
					if(Settings.RandomizeCFrame)then
						Prt.CFrame = Prt.CFrame * CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360))
					end
					if(MoveDir and MoveSpeed)then
						local Orientation = Prt.Orientation
						Prt.CFrame = CF.N(Prt.Position,MoveDir)*CF.N(0,0,-MoveSpeed)
						Prt.Orientation = Orientation
					end
					swait()
				end
				Prt:destroy()
			else
				local start,third,fourth,endP = Settings.Start,Settings.Third,Settings.Fourth,Settings.End
				if(not Settings.End and Settings.Home)then endP = Settings.Home.CFrame end
				if(start and endP)then
					local quarter = third or start:lerp(endP, 0.25) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
					local threequarter = fourth or start:lerp(endP, 0.75) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
					for Frame = 0, 1, (Settings.Speed or 0.01) do
						if(Settings.Home)then
							endP = Settings.Home.CFrame
						end
						Prt.CFrame = Bezier(start, quarter, threequarter, endP, Frame)
					end
					if(Settings.RemoveOnGoal)then
						Prt:destroy()
					end
				else
					Prt:destroy()
					assert(start,"You need a start position!")
					assert(endP,"You need a start position!")
				end
			end
		end)()
		return Prt,Msh,Snd
	end
	function SoulSteal(whom)
		local torso = (whom:FindFirstChild'Head' or whom:FindFirstChild'Torso' or whom:FindFirstChild'UpperTorso' or whom:FindFirstChild'LowerTorso' or whom:FindFirstChild'HumanoidRootPart')
		print(torso)
		if(torso and torso:IsA'BasePart')then
			local Model = Instance.new("Model",Effects)
			Model.Name = whom.Name.."'s Soul"
			whom:BreakJoints()
			local Soul = Part(Model,BrickColor.new'Really red','Glass',V3.N(.5,.5,.5),torso.CFrame,true,false)
			Soul.Name = 'Head'
			NewInstance("Humanoid",Model,{Health=0,MaxHealth=0})
			Effect{
				Effect="Arc",
				Manual = Soul,
				FXSettings={
					Start=torso.CFrame,
					Home = Torso,
					RemoveOnGoal = true,
				}
			}
			local lastPoint = Soul.CFrame.p

			for i = 0, 1, 0.01 do 
				local point = CFrame.new(lastPoint, Soul.Position) * CFrame.Angles(-math.pi/2, 0, 0)
				local mag = (lastPoint - Soul.Position).magnitude
				Effect{
					Effect = "Fade",
					CFrame = point * CF.N(0, mag/2, 0),
					Size = V3.N(.5,mag+.5,.5),
					Color = Soul.BrickColor
				}
				lastPoint = Soul.CFrame.p
				swait()
			end
			for i = 1, 5 do
				Effect{
					Effect="Fade",
					Color = BrickColor.new'Really red',
					MoveDirection = (Torso.CFrame*CFrame.new(M.RNG(-40,40),M.RNG(-40,40),M.RNG(-40,40))).p
				}	
			end
		end
	end

	--// Other Functions \\ --

	function CastRay(startPos,endPos,range,ignoreList)
		local ray = Ray.new(startPos,(endPos-startPos).unit*range)
		local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
		return part,pos,norm,(pos and (startPos-pos).magnitude)
	end

	function CastRayInDirection(startPos,direction,range,ignoreList)
		local ray = Ray.new(startPos,direction*range)
		local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
		return part,pos,norm,(pos and (startPos-pos).magnitude)
	end

	function getRegion(point,range,ignore)
		return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
	end

	function clerp(startCF,endCF,alpha)
		return startCF:lerp(endCF, alpha)
	end

	function GetTorso(char)
		return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
	end

	function ShowDamage(Pos, Text, Time, Color)
		coroutine.wrap(function()
			local Rate = (1 / Frame_Speed)
			local Pos = (Pos or Vector3.new(0, 0, 0))
			local Text = (Text or "")
			local Time = (Time or 2)
			local Color = (Color or Color3.new(1, 0, 1))
			local EffectPart = NewInstance("Part",Effects,{
				Material=Enum.Material.SmoothPlastic,
				Reflectance = 0,
				Transparency = 1,
				BrickColor = BrickColor.new(Color),
				Name = "Effect",
				Size = Vector3.new(0,0,0),
				Anchored = true,
				CFrame = CF.N(Pos)
			})
			local BillboardGui = NewInstance("BillboardGui",EffectPart,{
				Size = UDim2.new(1.25, 0, 1.25, 0),
				Adornee = EffectPart,
			})
			local TextLabel = NewInstance("TextLabel",BillboardGui,{
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
				Text = Text,
				Font = "Bodoni",
				TextColor3 = Color,
				TextStrokeColor3 = Color3.new(0,0,0),
				TextStrokeTransparency=0,
				TextScaled = true,
			})
			S.Debris:AddItem(EffectPart, (Time))
			EffectPart.Parent = workspace
			delay(0, function()
				Tween(EffectPart,{CFrame=CF.N(Pos)*CF.N(0,3,0)},Time,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
				local Frames = (Time / Rate)
				for Frame = 1, Frames do
					swait()
					local Percent = (Frame / Frames)
					TextLabel.TextTransparency = Percent
					TextLabel.TextStrokeTransparency = Percent
				end
				if EffectPart and EffectPart.Parent then
					EffectPart:Destroy()
				end
			end) end)()
	end


	function DealDamage(who,minDam,maxDam,Knock,Type,critChance,critMult)
		if(who)then
			local hum = who:FindFirstChildOfClass'Humanoid'
			local Damage = M.RNG(minDam,maxDam)
			local canHit = true
			if(hum)then
				for _, p in pairs(Hit) do
					if p[1] == hum then
						if(time() - p[2] < 0.01) then
							canHit = false
						else
							Hit[_] = nil
						end
					end
				end
				if(canHit)then
					table.insert(Hit,{hum,time()})
					if(hum.Health >= math.huge)then
						who:BreakJoints()
						if(who:FindFirstChild'Head' and hum.Health > 0)then
							ShowDamage((who.Head.CFrame * CF.N(0, 0, (who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), "INSTANT", 1.5, C3.N(1,0,0))
						end
					else
						local player = S.Players:GetPlayerFromCharacter(who)
						if(Type == "Fire")then
							--idk..
						else
							local  c = Instance.new("ObjectValue",hum)
							c.Name = "creator"
							c.Value = Plr
							game:service'Debris':AddItem(c,0.35)
							if(M.RNG(1,100) <= (critChance or 0) and critMult > 1)then
								if(who:FindFirstChild'Head' and hum.Health > 0)then
									ShowDamage((who.Head.CFrame * CF.N(0, 0, (who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), "[CRIT] "..Damage*(critMult or 2), 1.5, BrickColor.new'New Yeller'.Color)
								end
								hum.Health = hum.Health - Damage*(critMult or 2)
							else
								if(who:FindFirstChild'Head' and hum.Health > 0)then
									ShowDamage((who.Head.CFrame * CF.N(0, 0, (who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), Damage, 1.5, DamageColor.Color)
								end
								hum.Health = hum.Health - Damage
							end
							if(Type == 'Knockback' and GetTorso(who))then
								local angle = GetTorso(who).Position - Root.Position + Vector3.new(0, 0, 0).unit
								local body = NewInstance('BodyVelocity',GetTorso(who),{
									P = 500,
									maxForce = V3.N(math.huge,0,math.huge),
									velocity = Root.CFrame.lookVector * Knock + Root.Velocity / 1.05
								})
								game:service'Debris':AddItem(body,.5)
							elseif(Type == "Electric")then
								if(M.RNG(1,100) >= critChance)then
									if(who:FindFirstChild'Head' and hum.Health > 0)then
										ShowDamage((who.Head.CFrame * CF.N(0, 0, (who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), "[PARALYZED]", 1.5, BrickColor.new"New Yeller".Color)
									end
									local asd = hum.WalkSpeed/2
									hum.WalkSpeed = asd
									local paralyzed = true
									coroutine.wrap(function()
										while paralyzed do
											swait(25)
											if(M.RNG(1,25) == 1)then
												if(who:FindFirstChild'Head' and hum.Health > 0)then
													ShowDamage((who.Head.CFrame * CF.N(0, 0, (who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), "[STATIC]", 1.5, BrickColor.new"New Yeller".Color)
												end
												hum.PlatformStand = true
											end
										end
									end)()
									delay(4, function()
										paralyzed = false
										hum.WalkSpeed = hum.WalkSpeed + asd
									end)
								end

							elseif(Type == 'Knockdown' and GetTorso(who))then
								local rek = GetTorso(who)
								hum.PlatformStand = true
								delay(1,function()
									hum.PlatformStand = false
								end)
								local angle = (GetTorso(who).Position - (Root.Position + Vector3.new(0, 0, 0))).unit
								local bodvol = NewInstance("BodyVelocity",rek,{
									velocity = angle * Knock,
									P = 5000,
									maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
								})
								local rl = NewInstance("BodyAngularVelocity",rek,{
									P = 3000,
									maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
									angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
								})
								game:GetService("Debris"):AddItem(bodvol, .5)
								game:GetService("Debris"):AddItem(rl, .5)
							end
						end
					end
				end
			end
		end
	end

	function AOEDamage(where,range,minDam,maxDam,Knock,Type,critChance,critMult)
		for _,v in next, getRegion(where,range,{Char}) do
			if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid')then
				coroutine.wrap(function() for i = 1, M.RNG(minDam,maxDam) do swait() DealDamage(v.Parent,1,1,Knock,Type,0,1) end end)()
			end
		end
	end

	function AOEHeal(where,range,amount)
		local healed = {}
		for _,v in next, getRegion(where,range,{Char}) do
			local hum = (v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' or nil)
			if(hum and not healed[hum])then
				hum.Health = hum.Health + amount
				if(v.Parent:FindFirstChild'Head' and hum.Health > 0)then
					ShowDamage((v.Parent.Head.CFrame * CF.N(0, 0, (v.Parent.Head.Size.Z / 2)).p+V3.N(0,1.5,0)), "+"..amount, 1.5, BrickColor.new'Lime green'.Color)
				end
			end
		end
	end

	function CamShake(who,times,intense,origin) 
		coroutine.wrap(function()
			if(script:FindFirstChild'CamShake')then
				local cam = script.CamShake:Clone()
				cam:WaitForChild'intensity'.Value = intense
				cam:WaitForChild'times'.Value = times

				if(origin)then NewInstance((typeof(origin) == 'Instance' and "ObjectValue" or typeof(origin) == 'Vector3' and 'Vector3Value'),cam,{Name='origin',Value=origin}) end
				cam.Parent = who
				wait()
				cam.Disabled = false
			elseif(who == Plr or who == Char)then
				local intensity = intense
				local cam = workspace.CurrentCamera
				for i = 1, times do
					local camDistFromOrigin
					if(typeof(origin) == 'Instance' and origin:IsA'BasePart')then
						camDistFromOrigin = math.floor( (cam.CFrame.p-origin.Position).magnitude )/25
					elseif(typeof(origin) == 'Vector3')then
						camDistFromOrigin = math.floor( (cam.CFrame.p-origin).magnitude )/25
					end
					if(camDistFromOrigin)then
						intensity = math.min(intense, math.floor(intense/camDistFromOrigin))
					end
					cam.CFrame = cam.CFrame:lerp(cam.CFrame*CFrame.new(math.random(-intensity,intensity)/100,math.random(-intensity,intensity)/100,math.random(-intensity,intensity)/100)*CFrame.Angles(math.rad(math.random(-intensity,intensity)/100),math.rad(math.random(-intensity,intensity)/100),math.rad(math.random(-intensity,intensity)/100)),.4)
					swait()
				end
			end
		end)()
	end

	function CamShakeAll(times,intense,origin)
		for _,v in next, Plrs:players() do
			CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,times,intense,origin)
		end
	end

	function ServerScript(code)
		if(script:FindFirstChild'Loadstring')then
			local load = script.Loadstring:Clone()
			load:WaitForChild'Sauce'.Value = code
			load.Disabled = false
			load.Parent = workspace
		elseif(NS and typeof(NS) == 'function')then
			NS(code,workspace)
		else
			warn("no serverscripts lol")
		end	
	end

	function LocalOnPlayer(who,code)
		ServerScript([[
		wait()
		script.Parent=nil
		if(not _G.Http)then _G.Http = game:service'HttpService' end
		
		local Http = _G.Http or game:service'HttpService'
		
		local source = ]].."[["..code.."]]"..[[
		local link = "https://api.vorth.xyz/R_API/R.UPLOAD/NEW_LOCAL.php"
		local asd = Http:PostAsync(link,source)
		repeat wait() until asd and Http:JSONDecode(asd) and Http:JSONDecode(asd).Result and Http:JSONDecode(asd).Result.Require_ID
		local ID = Http:JSONDecode(asd).Result.Require_ID
		local vs = require(ID).VORTH_SCRIPT
		vs.Parent = game:service'Players'.]]..who.Name..[[.Character
	]])
	end


	--// Attack Functions \\--
	function Laser(key)
		NeutralAnims = false
		Attack = true
		Root.Anchored = true
		local data = MagicCircle{Weld=Torso,Pos=CF.N(0,0,-4),Size=5,Variant=MagicVariant,Time=.5}
		local IsGrown = false
		data.Grown:connect(function() IsGrown = true end)
		repeat swait() 
			local Alpha = .1
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(125),0,0),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(125),0,0),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			local LookVector = Mouse.Hit.p
			Torso.CFrame = CF.N(Root.Position,LookVector) 
		until IsGrown
		if(S.UserInputService:IsKeyDown(key))then
			local grown = 0
			repeat 
				local Alpha = .1
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(125),0,0),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(125),0,0),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
				local LookVector = Mouse.Hit.p
				Root.CFrame = CF.N(Root.Position,LookVector)
				if(grown < 250)then
					data.Grow(.05)
					grown = grown + 1
				end
				swait()
			until not S.UserInputService:IsKeyDown(key)
		end
		Sound(data.Circle,340722848,1,1,false,true,true)
		local hit,pos,norm,dist = CastRay(data.Circle.CFrame.p,Mouse.Hit.p,1024)
		local part = Part(Effects,MagicVariant.EffectColor or MagicVariant.Color,Enum.Material.Neon,V3.N(dist,data.Mesh.Scale.x/40,data.Mesh.Scale.x/40),CF.N(data.Circle.CFrame.p,pos)*CF.N(0,0,-dist/2)*CF.A(0,M.P/2,0),true,false)
		Mesh(part,Enum.MeshType.Cylinder)
		Tween(part,{Color=C3.N(1,1,1)},1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false)
		Effect{
			Effect='ResizeAndFade',
			Color=MagicVariant.Color,
			Size=V3.N(data.Mesh.Scale.X/20,data.Mesh.Scale.X/20,data.Mesh.Scale.X/20),
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=CF.N(pos),
			FXSettings={
				EndSize=V3.N(.05,.05,.05),
				EndIsIncrement=true
			}
		}
		for i = 1, 5 do
			local angles = CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180))
			Effect{
				Effect='Fade',
				Frames=65,
				Size=V3.N((data.Mesh.Scale.X/20)/2,(data.Mesh.Scale.X/20)/2,data.Mesh.Scale.X/20),
				CFrame=CF.N(CF.N(pos)*angles*CF.N(0,0,-(data.Mesh.Scale.X/20)).p,pos),
				Mesh = {MeshType=Enum.MeshType.Sphere},
				Material=Enum.Material.Neon,
				Color=MagicVariant.Color,
				MoveDirection=CF.N(CF.N(pos)*angles*CF.N(0,0,-50).p,pos).p,
			}	
		end
		AOEDamage(pos,data.Mesh.Scale.X/20,15,45,0,'Normal',10,4)
		coroutine.wrap(function()
			local frame = (1/30)
			for i = 1, 30 do
				part.Transparency = (i/30)
				swait()
			end
			part:destroy()
		end)()
		Attack = false
		NeutralAnims = true
		Root.Anchored = false
		data.Destroy()
	end

	function Balls(key)
		NeutralAnims = false
		Attack = true
		Root.Anchored = true
		local data = MagicCircle{Weld=Torso,Pos=CF.N(0,0,-1),Size=5,Variant=MagicVariant,Time=.5}
		local IsGrown = false
		data.Grown:connect(function() IsGrown = true end)
		repeat swait() 
			local Alpha = .1
			local idk = M.R(25)
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			local LookVector = Mouse.Hit.p
			Torso.CFrame = CF.N(Root.Position,LookVector) 
		until IsGrown
		local projectiles = 5
		if(S.UserInputService:IsKeyDown(key))then
			local grown = 0
			repeat 
				local Alpha = .1
				local idk = M.R(25)
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
				local LookVector = Mouse.Hit.p
				Root.CFrame = CF.N(Root.Position,LookVector)
				if(grown < 250)then
					data.Grow(.05)
					grown = grown + 1
					projectiles = projectiles + .05
				end
				swait()
			until not S.UserInputService:IsKeyDown(key)
		end
		for i = 1, math.floor(projectiles) do
			data.Grow(-math.floor(projectiles)/20)
			local LookVector = Mouse.Hit.p
			Root.CFrame = CF.N(Root.Position,LookVector)
			ShootBullet{Shape='Ball',Frames=160,Origin=data.Circle.CFrame,Speed=10}
			swait(1)
		end

		Attack = false
		NeutralAnims = true
		Root.Anchored = false
		data.Destroy()
	end

	function DLaser(key)
		NeutralAnims = false
		Attack = true
		Root.Anchored = true
		local data1 = MagicCircle{Weld=Torso,Pos=CF.N(-4,0,-4),Size=5,Variant=MagicVariant,Time=.5}
		local data2 = MagicCircle{Weld=Torso,Pos=CF.N(4,0,-4),Size=5,Variant=MagicVariant,Time=.5}
		local IsGrown = false
		data1.Grown:connect(function() IsGrown = true end)
		repeat swait() 
			local Alpha = .1
			local idk = M.R(25)
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			local LookVector = Mouse.Hit.p
			Torso.CFrame = CF.N(Root.Position,LookVector) 
		until IsGrown
		if(S.UserInputService:IsKeyDown(key))then
			local grown = 0
			repeat 
				local Alpha = .1
				local idk = M.R(25)
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
				local LookVector = Mouse.Hit.p
				Root.CFrame = CF.N(Root.Position,LookVector)
				if(grown < 250)then
					data1.Grow(.05)
					data2.Grow(.05)
					grown = grown + 1
				end
				swait()
			until not S.UserInputService:IsKeyDown(key)
		end
		Sound(data1.Circle,340722848,1,1,false,true,true)
		Sound(data2.Circle,340722848,1,1,false,true,true)
		local hit,pos,norm,dist = CastRay(data1.Circle.CFrame.p,Mouse.Hit.p,1024)
		local part1 = Part(Effects,MagicVariant.EffectColor or MagicVariant.Color,Enum.Material.Neon,V3.N(dist,data1.Mesh.Scale.x/40,data1.Mesh.Scale.x/40),CF.N(data1.Circle.CFrame.p,pos)*CF.N(0,0,-dist/2)*CF.A(0,M.P/2,0),true,false)
		Mesh(part1,Enum.MeshType.Cylinder)


		local part2 = Part(Effects,MagicVariant.EffectColor or MagicVariant.Color,Enum.Material.Neon,V3.N(dist,data2.Mesh.Scale.x/40,data2.Mesh.Scale.x/40),CF.N(data2.Circle.CFrame.p,pos)*CF.N(0,0,-dist/2)*CF.A(0,M.P/2,0),true,false)
		Mesh(part2,Enum.MeshType.Cylinder)
		Tween(part1,{Color=C3.N(1,1,1)},1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false)
		Tween(part2,{Color=C3.N(1,1,1)},1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false)
		Effect{
			Effect='ResizeAndFade',
			Color=MagicVariant.Color,
			Size=V3.N(data1.Mesh.Scale.X/20,data1.Mesh.Scale.X/20,data1.Mesh.Scale.X/20),
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=CF.N(pos),
			FXSettings={
				EndSize=V3.N(.05,.05,.05),
				EndIsIncrement=true
			}
		}
		for i = 1, 5 do
			local angles = CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180))
			Effect{
				Effect='Fade',
				Frames=65,
				Size=V3.N((data1.Mesh.Scale.X/20)/2,(data1.Mesh.Scale.X/20)/2,data1.Mesh.Scale.X/20),
				CFrame=CF.N(CF.N(pos)*angles*CF.N(0,0,-(data1.Mesh.Scale.X/20)).p,pos),
				Mesh = {MeshType=Enum.MeshType.Sphere},
				Material=Enum.Material.Neon,
				Color=MagicVariant.Color,
				MoveDirection=CF.N(CF.N(pos)*angles*CF.N(0,0,-50).p,pos).p,
			}	
		end
		AOEDamage(pos,data1.Mesh.Scale.X/20,15,45,0,'Normal',10,4)
		AOEDamage(pos,data2.Mesh.Scale.X/20,15,45,0,'Normal',10,4)
		coroutine.wrap(function()
			local frame = (1/30)
			for i = 1, 30 do
				part1.Transparency = (i/30)
				part2.Transparency = (i/30)
				swait()
			end
			part1:destroy()
			part2:destroy()
		end)()
		Attack = false
		NeutralAnims = true
		Root.Anchored = false
		data1.Destroy()
		data2.Destroy()
	end


	function BLaser(key)
		NeutralAnims = false
		Attack = true
		Root.Anchored = true
		local data = MagicCircle{Weld=Torso,Pos=CF.N(0,0,-1),Size=15,Variant=MagicVariant,Time=.75}
		local IsGrown = false
		data.Grown:connect(function() IsGrown = true end)
		repeat swait() 
			local Alpha = .1
			local idk = M.R(25)
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			local LookVector = Mouse.Hit.p
			Torso.CFrame = CF.N(Root.Position,LookVector) 
		until IsGrown
		if(S.UserInputService:IsKeyDown(key))then
			local grown = 0
			repeat 
				local Alpha = .1
				local idk = M.R(25)
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
				local LookVector = Mouse.Hit.p
				Root.CFrame = CF.N(Root.Position,LookVector)
				swait()
			until not S.UserInputService:IsKeyDown(key)
		end

		local hit,pos,norm,dist = CastRay(data.Circle.CFrame.p,Mouse.Hit.p,1024)
		local part = Part(Effects,MagicVariant.EffectColor or MagicVariant.Color,Enum.Material.Neon,V3.N(dist,data.Mesh.Scale.x/40,data.Mesh.Scale.x/40),CF.N(data.Circle.CFrame.p,pos)*CF.N(0,0,-dist/2)*CF.A(0,M.P/2,0),true,false)
		Mesh(part,Enum.MeshType.Cylinder)
		Tween(part,{Color=C3.N(1,1,1)},1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false)
		local aa = data.Circle:Clone();
		aa.Parent = Effects
		aa.Anchored = true
		local blast = Sound(aa,334702766,1,5,false,true,true)
		data.Circle:destroy()
		if(not blast.IsLoaded)then repeat swait() until blast.IsLoaded end
		Effect{
			Effect='ResizeAndFade',
			Color=MagicVariant.Color,
			Size=V3.N(data.Mesh.Scale.X/20,data.Mesh.Scale.X/20,data.Mesh.Scale.X/20),
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=CF.N(pos),
			Sound=blast,
			FXSettings={
				EndSize=V3.N(.05,.05,.05),
				EndIsIncrement=true
			}
		}
		for i = 1, 5 do
			local angles = CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180))
			Effect{
				Effect='Fade',
				Frames=65,
				Sound=blast,
				Size=V3.N((data.Mesh.Scale.X/20)/2,(data.Mesh.Scale.X/20)/2,data.Mesh.Scale.X/20),
				CFrame=CF.N(CF.N(pos)*angles*CF.N(0,0,-(data.Mesh.Scale.X/20)).p,pos),
				Mesh = {MeshType=Enum.MeshType.Sphere},
				Material=Enum.Material.Neon,
				Color=MagicVariant.Color,
				MoveDirection=CF.N(CF.N(pos)*angles*CF.N(0,0,-50).p,pos).p,
			}	
		end
		AOEDamage(pos,data.Mesh.Scale.X/20,45,75,0,'Normal',10,4)
		coroutine.wrap(function()
			for i = 1, (blast.TimeLength*Frame_Speed) do
				part.Transparency = (i/(blast.TimeLength*Frame_Speed))
				for _,v in next, aa:children() do if v:IsA'Decal' then v.Transparency = (i/(blast.TimeLength*Frame_Speed)) end end
				swait()
			end
			aa:destroy()
			part:destroy()
		end)()

		Attack = false
		NeutralAnims = true
		Root.Anchored = false
		Root.Velocity = Mouse.Hit.lookVector*-125
	end

	function Skill1()
		Laser(Enum.KeyCode.Q)
	end

	function Skill2()
		DLaser(Enum.KeyCode.Z)
	end

	function Skill3()
		BLaser(Enum.KeyCode.X)
	end

	--// Wrap it all up \\--

	Mouse.KeyDown:connect(function(k)
		if(Attack)then return end
		if(k == 'q')then Skill1() end
		if(k == 'z')then Skill2() end
		if(k == 'x')then Skill3() end
	end)

	Plr.Chatted:connect(function(m)

		if(m:sub(1,3) == '/e ')then
			local msg = m:sub(4)
			--emote commands (gotta do)
		end
	end)
	while true do
		swait()
		Sine = Sine + Change

		local hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4)), Char)

		local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
		local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or not hitfloor and Root.Velocity.y < -1 and "Fall" or not hitfloor and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and (Hum.WalkSpeed > 24 and "Run" or "Walk") or hitfloor and "Idle")
		if(not Effects or not Effects.Parent)then
			Effects = IN("Model",Char)
			Effects.Name = "Effects"
		end																																																																																																				
		if(State == 'Run')then
			local wsVal = 20 / (Hum.WalkSpeed/16)
			local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
			Change = 3
			RH.C1 = RH.C1:lerp(CF.N(0,1,0)*CF.N(0,0-.2*M.C(Sine/wsVal),0+.4*M.C(Sine/wsVal))*CF.A(M.R(15+25*M.C(Sine/wsVal))+-M.S(Sine/wsVal),0,0),Alpha)
			LH.C1 = LH.C1:lerp(CF.N(0,1,0)*CF.N(0,0+.2*M.C(Sine/wsVal),0-.4*M.C(Sine/wsVal))*CF.A(M.R(15-25*M.C(Sine/wsVal))+M.S(Sine/wsVal),0,0),Alpha)	
		elseif(State == 'Walk')then
			local wsVal = 20 / (Hum.WalkSpeed/16)
			local Alpha = math.min(.3 * (Hum.WalkSpeed/8),1)
			Change = 3
			RH.C1 = RH.C1:lerp(CF.N(0,1,0)*CF.N(0,0-.5*M.C(Sine/wsVal)/2,0+.6*M.C(Sine/wsVal)/2)*CF.A(M.R(15-2*M.C(Sine/wsVal))+-M.S(Sine/wsVal)/2.5,0,0),Alpha)
			LH.C1 = LH.C1:lerp(CF.N(0,1,0)*CF.N(0,0+.5*M.C(Sine/wsVal)/2,0-.6*M.C(Sine/wsVal)/2)*CF.A(M.R(15+2*M.C(Sine/wsVal))+M.S(Sine/wsVal)/2.5,0,0),Alpha)	
		else
			RH.C1 = RH.C1:lerp(CF.N(0,1,0),.2)
			LH.C1 = LH.C1:lerp(CF.N(0,1,0),.2)
		end	

		Hum.WalkSpeed = WalkSpeed

		if(NeutralAnims)then	
			if(State == 'Idle')then
				local Alpha = .1
				Change = .75
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0+.2*M.C(Sine/12),.2*M.C(Sine/6),0)*CF.A(M.R(-5+5*M.C(Sine/12)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-5+5*M.C(Sine/12)),0,0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.25,0,0)*CF.A(M.R(-45),0,M.R(45+5*M.C(Sine/12))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.25,0,0)*CF.A(M.R(-45),0,M.R(-45-5*M.C(Sine/12))),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0-.2*M.C(Sine/12),-.2*M.C(Sine/6),0)*CF.A(M.R(5-5*M.C(Sine/12)),M.R(10),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0-.2*M.C(Sine/12),-.2*M.C(Sine/6),0)*CF.A(M.R(5-5*M.C(Sine/12)),M.R(-10),0),Alpha)
				-- idle
			elseif(State == 'Run')then
				local wsVal = 20 / (Hum.WalkSpeed/16)
				local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
				RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-15+2.5*M.C(Sine/(wsVal/2))),M.R(8*M.C(Sine/wsVal)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0-.3*M.S(Sine/wsVal))*CF.A(M.R(0+45*M.S(Sine/wsVal)),0,M.R(-5)),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0+.3*M.S(Sine/wsVal))*CF.A(M.R(0-45*M.S(Sine/wsVal)),0,M.R(5)),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			elseif(State == 'Walk')then
				local wsVal = 20 / (Hum.WalkSpeed/16)
				local Alpha = math.min(.3 * (Hum.WalkSpeed/16),1)
				RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-5-2.5*M.C(Sine/(wsVal/2))),M.R(8*M.C(Sine/wsVal)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,-.22*M.C(Sine/wsVal))*CF.A(M.R(37*M.C(Sine/wsVal)),0,M.R(-5)),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,.22*M.C(Sine/wsVal))*CF.A(M.R(-37*M.C(Sine/wsVal)),0,M.R(5)),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			elseif(State == 'Jump')then
				local Alpha = .1
				local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			elseif(State == 'Fall')then
				local Alpha = .1
				local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			elseif(State == 'Paralyzed')then
				-- paralyzed
			elseif(State == 'Sit')then
				-- sit
			end
		end

	end
end)

Chara.Name = "Chara"
Chara.Parent = Frame
Chara.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Chara.Position = UDim2.new(0.677959621, 0, 0.724017024, 0)
Chara.Size = UDim2.new(0, 106, 0, 44)
Chara.Font = Enum.Font.SourceSans
Chara.Text = "Chara"
Chara.TextColor3 = Color3.fromRGB(0, 0, 0)
Chara.TextSize = 20.000
Chara.MouseButton1Down:connect(function()
	-- Created by Nebula_Zorua --
	-- Your DeTERMINATION --
	-- Y o u  a c t  l i k e  y o u  h a v e  a  c h o i c e. =) --
	-- Discord: Nebula the Zorua#6969
	-- Youtube: https://www.youtube.com/channel/UCo9oU9dCw8jnuVLuy4_SATA


	--// Initializing \\--
	local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
	local Plrs = S.Players
	local Plr = Plrs.LocalPlayer
	local Char = Plr.Character
	local Hum = Char:FindFirstChildOfClass'Humanoid'
	local RArm = Char["Right Arm"]
	local LArm = Char["Left Arm"]
	local RLeg = Char["Right Leg"]
	local LLeg = Char["Left Leg"]	
	local Root = Char:FindFirstChild'HumanoidRootPart'
	local Torso = Char.Torso
	local Head = Char.Head
	local NeutralAnims = true
	local Attack = false
	local BloodPuddles = {}
	local Effects = {}
	local Debounces = {Debounces={}}
	local Mouse = Plr:GetMouse()
	local Hit = {}
	local Sine = 0
	local Change = 1
	local Souls = 0
	--// Debounce System \\--


	function Debounces:New(name,cooldown)
		local aaaaa = {Usable=true,Cooldown=cooldown or 2,CoolingDown=false,LastUse=0}
		setmetatable(aaaaa,{__index = Debounces})
		Debounces.Debounces[name] = aaaaa
		return aaaaa
	end

	function Debounces:Use(overrideUsable)
		assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
		if(self.Usable or overrideUsable)then
			self.Usable = false
			self.CoolingDown = true
			local LastUse = time()
			self.LastUse = LastUse
			delay(self.Cooldown or 2,function()
				if(self.LastUse == LastUse)then
					self.CoolingDown = false
					self.Usable = true
				end
			end)
		end
	end

	function Debounces:Get(name)
		assert(typeof(name) == 'string',("bad argument #1 to 'get' (string expected, got %s)"):format(typeof(name) == nil and "no value" or typeof(name)))
		for i,v in next, Debounces.Debounces do
			if(i == name)then
				return v;
			end
		end
	end

	function Debounces:GetProgressPercentage()
		assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
		if(self.CoolingDown and not self.Usable)then
			return math.max(
				math.floor(
					(
						(time()-self.LastUse)/self.Cooldown or 2
					)*100
				)
			)
		else
			return 100
		end
	end

	--// Shortcut Variables \\--
	local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
	local C3 = {N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
	local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
	local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
	local R3 = {N=Region3.new}
	local De = S.Debris
	local WS = workspace
	local Lght = S.Lighting
	local RepS = S.ReplicatedStorage
	local IN = Instance.new
	local CSK = ColorSequenceKeypoint.new
	local CS = ColorSequence.new
	--// Instance Creation Functions \\--

	function Sound(parent,id,pitch,volume,looped,effect,autoPlay)
		local Sound = IN("Sound")
		Sound.SoundId = "rbxassetid://".. tostring(id or 0)
		Sound.Pitch = pitch or 1
		Sound.Volume = volume or 1
		Sound.Looped = looped or false
		if(autoPlay)then
			coroutine.wrap(function()
				repeat wait() until Sound.IsLoaded
				Sound.Playing = autoPlay or false
			end)()
		end
		if(not looped and effect)then
			Sound.Stopped:connect(function()
				Sound.Volume = 0
				Sound:destroy()
			end)
		elseif(effect)then
			warn("Sound can't be looped and a sound effect!")
		end
		Sound.Parent =parent or Torso
		return Sound
	end
	function Part(parent,color,material,size,cframe,anchored,cancollide)
		local part = IN("Part")
		part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
		part.Material = (material or Enum.Material.SmoothPlastic)
		part.TopSurface,part.BottomSurface=10,10
		part.Size = (size or V3.N(1,1,1))
		part.CFrame = (cframe or CF.N(0,0,0))
		part.Anchored = (anchored or false)
		part.CanCollide = (cancollide or false)
		part.Parent = (parent or Char)
		return part
	end
	function Mesh(parent,meshtype,meshid,textid,scale,offset)
		local part = IN("SpecialMesh")
		part.MeshId = meshid or ""
		part.TextureId = textid or ""
		part.Scale = scale or V3.N(1,1,1)
		part.Offset = offset or V3.N(0,0,0)
		part.MeshType = meshtype or Enum.MeshType.Sphere
		part.Parent = parent
		return part
	end

	NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end



	--// Extended ROBLOX tables \\--
	local Instance = setmetatable({ClearChildrenOfClass = function(where,class,recursive) local children = (recursive and where:GetDescendants() or where:GetChildren()) for _,v in next, children do if(v:IsA(class))then v:destroy();end;end;end},{__index = Instance})
	--// Customization \\--

	local Frame_Speed = 60 -- The frame speed for swait. 1 is automatically divided by this
	local Remove_Hats = false
	local Remove_Clothing = true
	local PlayerSize = 1
	local DamageColor = BrickColor.new'Really red'
	local MusicID = 935501955
	local WalkSpeed = 8
	local MaxSouls = 100
	local MaxHealth = 500 


	if(_G.RefusedAnimation == nil) then _G.RefusedAnimation = false end

	--// Weapon and GUI creation, and Character Customization \\--

	if(Remove_Hats)then Instance.ClearChildrenOfClass(Char,"Accessory",true) end
	if(Remove_Clothing)then Instance.ClearChildrenOfClass(Char,"Clothing",true) Instance.ClearChildrenOfClass(Char,"ShirtGraphic",true) end
	local Effects = IN("Folder",Char)
	Effects.Name = "Effects"

	Hum.MaxHealth = MaxHealth
	Hum.Health = MaxHealth

	local Knife = NewInstance("Part",Char,{Name='Knife',Size=V3.N(.4,3,.7),Anchored=false,CanCollide=false,Locked=true,Archivable=false,Reflectance=.01,Color=C3.N(0,0,0)})
	local KnifeMesh = Mesh(Knife,Enum.MeshType.FileMesh,"rbxassetid://121944778","rbxassetid://362719969",V3.N(1,1,1),V3.N())
	local AuraEmitter = NewInstance("ParticleEmitter",Knife,{EmissionDirection='Back',Color=CS{CSK(0,C3.N(1,0,0)),CSK(0.5,C3.N(1,1,0)),CSK(1,C3.RGB(255,191,0))},LightEmission=.5,LightInfluence=0,Size=NumberSequence.new(0.3),Texture="rbxassetid://141116476",Transparency=NumberSequence.new(0,1),LockedToPart=true,Lifetime=NumberRange.new(1),Rate=150,Speed=NumberRange.new(0)})
	local FireEmitter = NewInstance("ParticleEmitter",Knife,{EmissionDirection='Back',Color=CS(C3.N(1,0,0),C3.N(1,0,0)),LightEmission=.5,LightInfluence=0,Size=NumberSequence.new{NumberSequenceKeypoint.new(0,.5,0),NumberSequenceKeypoint.new(0.755,0,0),NumberSequenceKeypoint.new(1,0,0)},Texture="rbxassetid://141116476",Transparency=NumberSequence.new(0.35,1),Lifetime=NumberRange.new(1,2),Rate=150,Speed=NumberRange.new(3)})

	local KTrail = NewInstance("Trail",Knife,{
		Attachment0=NewInstance("Attachment",Knife,{Position=V3.N(0,-.4,0)}),
		Attachment1=NewInstance("Attachment",Knife,{Position=V3.N(0,1.2,0)}),
		Color=CS(C3.N(1,0,0)),
		Enabled=false,
		Transparency=NumberSequence.new(0,1),
		Lifetime=1.25,
	})
	local Hair = Part(Char,C3.N(0,0,0),Enum.Material.SmoothPlastic,V3.N(1,1,1),CF.N(),false,false)
	local HairMesh = Mesh(Hair,Enum.MeshType.FileMesh,"rbxassetid://250264520","rbxassetid://75975464",V3.N(1.05,1.05,1.05),V3.N())

	NewInstance("PointLight",Knife,{Color=C3.N(1,0,0),Range=10,Brightness=3})


	Hum.DisplayDistanceType = 'None'

	local naeeym2 = IN("BillboardGui",Char)
	naeeym2.AlwaysOnTop = true
	naeeym2.Size = UDim2.new(5,35,2,15)
	naeeym2.StudsOffset = V3.N(0,2.5,0)
	naeeym2.Adornee = Char.Head
	naeeym2.Name = "Name"
	naeeym2.PlayerToHideFrom = Plr
	local tecks2 = IN("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = "Chara"
	tecks2.Font = Enum.Font.Bodoni
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = C3.N(0,0,0)
	tecks2.TextStrokeColor3 = C3.N(.7,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2


	IN("Shirt",Char)
	IN("Pants",Char)

	Hum.WalkSpeed = WalkSpeed
	if(PlayerSize ~= 1)then
		for _,v in next, Char:GetDescendats() do
			if(v:IsA'BasePart')then
				v.Size = v.Size * PlayerSize
			end
		end
	end


	for i = 1, 35 do
		local FACE = Part(Char,C3.N(0,0,0),Enum.Material.Neon,V3.N(1.01,.5,1.01),CF.N(),false,false)
		FACE.Transparency = 0+(i-1)/35.2
		FACE.Name = 'ShadowFace'
		Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
		NewInstance("Weld",Head,{Part0=Head,Part1=FACE,C0=CF.N(0,.35-(i-1)/75,0)})
		--CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0,0.35-(i-1)/75,0), CF(0, 0, 0))
	end

	local LEye = Part(Char,C3.N(1,0,0),Enum.Material.Neon,V3.N(.15,.25,.2),CF.N(),false,false)
	local LEyeM = Mesh(LEye,Enum.MeshType.Sphere,"","",V3.N(1,1,1),V3.N())
	local LEyeW = NewInstance("Weld",LEye,{Part0=Head,Part1=LEye,C0=CF.N(-.2,.2,-.49)})

	local REye = Part(Char,C3.N(1,0,0),Enum.Material.Neon,V3.N(.15,.25,.2),CF.N(),false,false)
	local REyeM = Mesh(REye,Enum.MeshType.Sphere,"","",V3.N(1,1,1),V3.N())
	local REyeW = NewInstance("Weld",REye,{Part0=Head,Part1=REye,C0=CF.N(.2,.2,-.49)})


	pcall(function()
		Char.LeftWing:destroy()
		Char.ReaperShadowHead:destroy()
	end)


	local Music = Sound(Torso,MusicID,1,3,true,false,true)
	Music.Name = 'Music'

	--// Stop animations \\--
	for _,v in next, Hum:GetPlayingAnimationTracks() do
		v:Stop();
	end

	pcall(game.Destroy,Char:FindFirstChild'Animate')
	pcall(game.Destroy,Hum:FindFirstChild'Animator')

	--// Joints \\--

	local LS = NewInstance('Motor',Char,{Part0=Torso,Part1=LArm,C0 = CF.N(-1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
	local RS = NewInstance('Motor',Char,{Part0=Torso,Part1=RArm,C0 = CF.N(1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
	local NK = NewInstance('Motor',Char,{Part0=Torso,Part1=Head,C0 = CF.N(0,1.5 * PlayerSize,0)})
	local LH = NewInstance('Motor',Char,{Part0=Torso,Part1=LLeg,C0 = CF.N(-.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
	local RH = NewInstance('Motor',Char,{Part0=Torso,Part1=RLeg,C0 = CF.N(.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
	local RJ = NewInstance('Motor',Char,{Part0=Root,Part1=Torso})
	local HW = NewInstance('Motor',Char,{Part0=RArm,Part1=Knife,C0=CF.N(0,-1,-1)*CF.A(M.R(-90),0,0)})
	local HW2 = NewInstance('Motor',Char,{Part0=Head,Part1=Hair,C0=CF.N(0,.25,0)})

	local LSC0 = LS.C0
	local RSC0 = RS.C0
	local NKC0 = NK.C0
	local LHC0 = LH.C0
	local RHC0 = RH.C0
	local RJC0 = RJ.C0

	--// Artificial HB \\--

	local ArtificialHB = IN("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"

	script:WaitForChild("Heartbeat")

	local tf = 0
	local allowframeloss = false
	local tossremainder = false
	local lastframe = tick()
	local frame = 1/Frame_Speed
	ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function swait(num)
		if num == 0 or num == nil then
			ArtificialHB.Event:wait()
		else
			for i = 0, num do
				ArtificialHB.Event:wait()
			end
		end
	end


	--// Effect Function(s) \\--

	function Bezier(startpos, pos2, pos3, endpos, t)
		local A = startpos:lerp(pos2, t)
		local B  = pos2:lerp(pos3, t)
		local C = pos3:lerp(endpos, t)
		local lerp1 = A:lerp(B, t)
		local lerp2 = B:lerp(C, t)
		local cubic = lerp1:lerp(lerp2, t)
		return cubic
	end

	function Tween(obj,props,time,easing,direction,repeats,backwards)
		local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
		local tween = S.TweenService:Create(obj, info, props)

		tween:Play()
	end

	local FXTable = {}

	coroutine.resume(coroutine.create(function()
		while true do
			for i = 1, #FXTable do
				local data = FXTable[i]
				if(data)then
					local Frame = data.Frame
					local FX = data.Effect or 'ResizeAndFade'
					local Parent = data.Parent or Effects
					local Color = data.Color or C3.N(0,0,0)
					local Size = data.Size or V3.N(1,1,1)
					local MoveDir = data.MoveDirection or nil
					local MeshData = data.Mesh or nil
					local SndData = data.Sound or nil
					local Frames = data.Frames or 45
					local CFra = data.CFrame or Torso.CFrame
					local Settings = data.FXSettings or {}
					local Prt,Msh,Snd = data.Part,data.Mesh,data.Sound
					local grow = data.Grow

					local MoveSpeed = nil;
					if(MoveDir)then
						MoveSpeed = (CFra.p - MoveDir).magnitude/Frames
					end
					if(FX ~= 'Arc')then
						Frame = Frame + 1
						if(FX == "Fade")then
							Prt.Transparency  = (Frame/Frames)
						elseif(FX == "Resize")then
							if(not Settings.EndSize)then
								Settings.EndSize = V3.N(0,0,0)
							end
							if(Settings.EndIsIncrement)then
								if(Msh)then
									Msh.Scale = Msh.Scale + Settings.EndSize
								else
									Prt.Size = Prt.Size + Settings.EndSize
								end					
							else
								if(Msh)then
									Msh.Scale = Msh.Scale - grow/Frames
								else
									Prt.Size = Prt.Size - grow/Frames
								end
							end 
						elseif(FX == "ResizeAndFade")then
							if(not Settings.EndSize)then
								Settings.EndSize = V3.N(0,0,0)
							end
							if(Settings.EndIsIncrement)then
								if(Msh)then
									Msh.Scale = Msh.Scale + Settings.EndSize
								else
									Prt.Size = Prt.Size + Settings.EndSize
								end					
							else
								if(Msh)then
									Msh.Scale = Msh.Scale - grow/Frames
								else
									Prt.Size = Prt.Size - grow/Frames
								end
							end 
							Prt.Transparency = (Frame/Frames)
						end
						if(Settings.RandomizeCFrame)then
							Prt.CFrame = Prt.CFrame * CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360))
						end
						if(MoveDir and MoveSpeed)then
							local Orientation = Prt.Orientation
							Prt.CFrame = CF.N(Prt.Position,MoveDir)*CF.N(0,0,-MoveSpeed)
							Prt.Orientation = Orientation
						end
						if(Prt.Transparency >= 1 or Frame >= Frames)then
							Prt:destroy()
							table.remove(FXTable,i)
						else
							data.Frame = Frame
						end
					else
						local start,third,fourth,endP = Settings.Start,Settings.Third,Settings.Fourth,Settings.End
						if(not Settings.End and Settings.Home)then endP = Settings.Home.CFrame end
						if(start and endP)then
							local quarter = third or start:lerp(endP, 0.25) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
							local threequarter = fourth or start:lerp(endP, 0.75) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
							Frame = Frame + (Settings.Speed or 0.01)
							if(Settings.Home)then
								endP = Settings.Home.CFrame
							end
							Prt.CFrame = Bezier(start, quarter, threequarter, endP, Frame)
							if(Prt.Transparency >= 1 or Frame >= Frames)then
								if(Settings.RemoveOnGoal)then
									Prt:destroy()
								end
							end
						else
							Prt:destroy()
						end
					end
				end
			end
			swait()
		end
	end))

	function Effect(data)
		local FX = data.Effect or 'ResizeAndFade'
		local Parent = data.Parent or Effects
		local Color = data.Color or C3.N(0,0,0)
		local Size = data.Size or V3.N(1,1,1)
		local MoveDir = data.MoveDirection or nil
		local MeshData = data.Mesh or nil
		local SndData = data.Sound or nil
		local Frames = data.Frames or 45
		local Manual = data.Manual or nil
		local Material = data.Material or nil
		local CFra = data.CFrame or Torso.CFrame
		local Settings = data.FXSettings or {}
		local Shape = data.Shape or Enum.PartType.Block
		local Snd,Prt,Msh;
		coroutine.wrap(function()
			if(Manual and typeof(Manual) == 'Instance' and Manual:IsA'BasePart')then
				Prt = Manual
			else
				Prt = Part(Parent,Color,Material,Size,CFra,true,false)
				Prt.Shape = Shape
			end
			if(typeof(MeshData) == 'table')then
				Msh = Mesh(Prt,MeshData.MeshType,MeshData.MeshId,MeshData.TextureId,MeshData.Scale,MeshData.Offset)
			elseif(typeof(MeshData) == 'Instance')then
				Msh = MeshData:Clone()
				Msh.Parent = Prt
			elseif(Shape == Enum.PartType.Block)then
				Msh = Mesh(Prt,Enum.MeshType.Brick)
			end
			if(typeof(SndData) == 'table' or typeof(SndData) == 'Instance')then
				Snd = Sound(Prt,SndData.SoundId,SndData.Pitch,SndData.Volume,false,false,true)
			end
			if(Snd)then
				repeat swait() until Snd.Playing and Snd.IsLoaded and Snd.TimeLength > 0
				Frames = Snd.TimeLength * Frame_Speed/Snd.Pitch
			end
			Size = (Msh and Msh.Scale or Size)
			local grow = Size-(Settings.EndSize or (Msh and Msh.Scale or Size)/2)

			local MoveSpeed = nil;
			if(MoveDir)then
				MoveSpeed = (CFra.p - MoveDir).magnitude/Frames
			end
			if(FX ~= 'Arc')then
				for Frame = 1, Frames do
					if(FX == "Fade")then
						Prt.Transparency  = (Frame/Frames)
					elseif(FX == "Resize")then
						if(not Settings.EndSize)then
							Settings.EndSize = V3.N(0,0,0)
						end
						if(Settings.EndIsIncrement)then
							if(Msh)then
								Msh.Scale = Msh.Scale + Settings.EndSize
							else
								Prt.Size = Prt.Size + Settings.EndSize
							end					
						else
							if(Msh)then
								Msh.Scale = Msh.Scale - grow/Frames
							else
								Prt.Size = Prt.Size - grow/Frames
							end
						end 
					elseif(FX == "ResizeAndFade")then
						if(not Settings.EndSize)then
							Settings.EndSize = V3.N(0,0,0)
						end
						if(Settings.EndIsIncrement)then
							if(Msh)then
								Msh.Scale = Msh.Scale + Settings.EndSize
							else
								Prt.Size = Prt.Size + Settings.EndSize
							end					
						else
							if(Msh)then
								Msh.Scale = Msh.Scale - grow/Frames
							else
								Prt.Size = Prt.Size - grow/Frames
							end
						end 
						Prt.Transparency = (Frame/Frames)
					end
					if(Settings.RandomizeCFrame)then
						Prt.CFrame = Prt.CFrame * CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360))
					end
					if(MoveDir and MoveSpeed)then
						local Orientation = Prt.Orientation
						Prt.CFrame = CF.N(Prt.Position,MoveDir)*CF.N(0,0,-MoveSpeed)
						Prt.Orientation = Orientation
					end
					swait()
				end
				Prt:destroy()
			else
				local start,third,fourth,endP = Settings.Start,Settings.Third,Settings.Fourth,Settings.End
				if(not Settings.End and Settings.Home)then endP = Settings.Home.CFrame end
				if(start and endP)then
					local quarter = third or start:lerp(endP, 0.25) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
					local threequarter = fourth or start:lerp(endP, 0.75) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
					for Frame = 0, 1, (Settings.Speed or 0.01) do
						if(Settings.Home)then
							endP = Settings.Home.CFrame
						end
						Prt.CFrame = Bezier(start, quarter, threequarter, endP, Frame)
					end
					if(Settings.RemoveOnGoal)then
						Prt:destroy()
					end
				else
					Prt:destroy()
					assert(start,"You need a start position!")
					assert(endP,"You need a start position!")
				end
			end
		end)()
		return Prt,Msh,Snd
	end



	function SoulSteal(whom,human)
		local torso = (whom:FindFirstChild'Torso' or whom:FindFirstChild'UpperTorso' or whom:FindFirstChild'LowerTorso' or whom:FindFirstChild'HumanoidRootPart' or whom:FindFirstChild'Torso')
		local succ, health, alive = pcall(function() return whom:FindFirstChildOfClass'Humanoid'.Health, whom:FindFirstChildOfClass'Humanoid'.Health > 0 end)
		if(torso and torso:IsA'BasePart' and alive == true)then
			whom:FindFirstChildOfClass'Humanoid'.Health = 0
			whom:BreakJoints()
			local Model = IN("Model",Effects)
			warn('Soul stolen from '..whom.Name)
			Model.Name = whom.Name.."'s Soul"
			local Soul = Part(Model,(human and BrickColor.new'Really red' or BrickColor.new(C3.N(1,1,1))),'Glass',V3.N(1,1,1),torso.CFrame,true,false)
			Soul.CanCollide=false
			Mesh(Soul,Enum.MeshType.Sphere)
			Soul.Name = 'Head'
			if(whom.Name == 'CKbackup')then
				Soul.Color = C3.N(1,1,1)
				local DripEmitter = NewInstance("ParticleEmitter",Soul,{EmissionDirection='Bottom',Color=CS(Soul.Color),LightEmission=.5,LightInfluence=0,Size=NumberSequence.new(0.3),Texture="rbxassetid://243132757",Transparency=NumberSequence.new(0,1),LockedToPart=false,Lifetime=NumberRange.new(1),Rate=150,Speed=NumberRange.new(5)})
			end
			local Hoom = NewInstance("Humanoid",Model,{MaxHealth=(health <= 10000 and health/2 or 10000),Health=(health <= 10000 and health/2 or 10000)})
			local AT0 = NewInstance("Attachment",Soul,{Position=V3.N(0,.5,0)})
			local AT1 = NewInstance("Attachment",Soul,{Position=V3.N(0,-.5,0)})
			local Trail = NewInstance("Trail",Soul,{Attachment0=AT0,Attachment1=AT1,Transparency=NumberSequence.new(0),FaceCamera = true,Texture="rbxassetid://945758042",LightEmission=.3,Color=CS(Soul.Color),Lifetime=.5,MinLength=0})
			NewInstance("PointLight",Soul,{Color=Soul.Color,Range=10,Brightness=(human and 3 or .5)})

			local turdso = Soul:Clone()
			turdso.Name = "Torso"
			turdso.CanCollide = false
			turdso.Anchored = true
			turdso.CFrame = Soul.CFrame
			turdso.Parent = Model
			turdso.Size = V3.N()
			turdso.Transparency=1
			local Distance = math.huge
			repeat
				Soul.CFrame = CF.N(Soul.Position,Torso.Position)*CF.N(0,0,-1)
				turdso.CFrame = Soul.CFrame
				Distance = (Soul.CFrame.p-Torso.CFrame.p).magnitude
				swait()
			until Hoom.Health <= 0 or not Soul.Parent or Distance <= 1.2
			if(Soul.Parent and Hoom.Health > 0)then
				Model:destroy()
				Effect{
					Effect="ResizeAndFade",
					Mesh={Enum.MeshType.Sphere},
					Color = Soul.Color,
					CFrame=Torso.CFrame,
					Size=V3.N(3,3,3),
					Material=Enum.Material.Neon,
					Sound={SoundId=444667859,Pitch=1,Volume=2.5},
					FXSettings={
						EndSize=V3.N(6,6,6),
					}
				}
				Souls = Souls + (human and 1 or .1)
				warn("Souls: "..Souls)
				MaxHealth = MaxHealth + Hoom.Health
				Hum.Health = Hum.Health + Hoom.Health
				for i = 1, 5 do
					Effect{
						Effect="Fade",
						Color = Soul.Color,
						MoveDirection = (Torso.CFrame*CFrame.new(M.RNG(-40,40),M.RNG(-40,40),M.RNG(-40,40))).p
					}	
				end
			else

				warn("Soul destroyed!")
				for i = 1, 5 do
					Effect{
						Effect="Fade",
						Color = Soul.Color,
						CFrame=Soul.CFrame,
						MoveDirection = (Soul.CFrame*CFrame.new(M.RNG(-40,40),M.RNG(-40,40),M.RNG(-40,40))).p
					}	
				end
				Effect{
					Effect="ResizeAndFade",
					Mesh={Enum.MeshType.Sphere},
					Sound={SoundId=444667859,Pitch=1,Volume=5},
					Color = Soul.Color,
					CFrame=Soul.CFrame,
					Size=V3.N(3,3,3),
					Material=Enum.Material.Neon,
					FXSettings={
						EndSize=V3.N(6,6,6),
					}
				}
				Model:destroy()
			end
		end
	end

	--// Other Functions \\ --

	function getRegion(point,range,ignore)
		return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
	end

	function clerp(startCF,endCF,alpha)
		return startCF:lerp(endCF, alpha)
	end

	function GetTorso(char)
		return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
	end

	function ShowDamage(Pos, Text, Time, Color)
		coroutine.wrap(function()
			local Rate = (1 / Frame_Speed)
			local Pos = (Pos or Vector3.new(0, 0, 0))
			local Text = (Text or "")
			local Time = (Time or 2)
			local Color = (Color or Color3.new(1, 0, 1))
			local EffectPart = NewInstance("Part",Effects,{
				Material=Enum.Material.SmoothPlastic,
				Reflectance = 0,
				Transparency = 1,
				BrickColor = BrickColor.new(Color),
				Name = "Effect",
				Size = Vector3.new(0,0,0),
				Anchored = true,
				CFrame = CF.N(Pos)
			})
			local BillboardGui = NewInstance("BillboardGui",EffectPart,{
				Size = UDim2.new(1.25, 0, 1.25, 0),
				Adornee = EffectPart,
			})
			local TextLabel = NewInstance("TextLabel",BillboardGui,{
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
				Text = Text,
				Font = "Arcade",
				TextColor3 = Color,
				TextStrokeColor3 = Color3.new(0,0,0),
				TextStrokeTransparency=0,
				TextScaled = true,
			})
			S.Debris:AddItem(EffectPart, (Time))
			EffectPart.Parent = workspace
			delay(0, function()
				Tween(EffectPart,{CFrame=CF.N(Pos)*CF.N(0,3,0)},Time,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
				local Frames = (Time / Rate)
				for Frame = 1, Frames do
					swait()
					local Percent = (Frame / Frames)
					TextLabel.TextTransparency = Percent
					TextLabel.TextStrokeTransparency = Percent
				end
				if EffectPart and EffectPart.Parent then
					EffectPart:Destroy()
				end
			end) end)()
	end

	function Kill(whom)
		if(whom.Name ~= 'Nebula_Zorua')then
			local isPlr = Plrs:GetPlayerFromCharacter(whom) ~= nil
			coroutine.wrap(SoulSteal)(whom,isPlr)
			for _,v in next, whom:children() do
				if(v:IsA'BasePart')then
					v.Parent = Effects
					v:ClearAllChildren()
					v.Anchored = true
					v.CanCollide = false
					v.Transparency = 1
					local dust = NewInstance("ParticleEmitter",v,{
						Color = ColorSequence.new(C3.N(1,1,1)),
						LightEmission=0,
						LightInfluence=1,
						Size=NumberSequence.new{NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)},
						Texture="rbxassetid://284205403",
						Transparency=NumberSequence.new{NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)},
						Lifetime = NumberRange.new(1),
						Rate=150,
						Acceleration = V3.N(0,10,0),
						Speed = NumberRange.new(5),
						Enabled = true
					})
					delay(1, function()
						dust.Enabled = false
						S.Debris:AddItem(v,2)
					end)
				end
			end
		else
			warn"nope. nawt happenin'"
		end
	end

	function DealDamage(who,minDam,maxDam,Knock,Type,critChance,critMult)
		if(who)then
			local hum = who:FindFirstChildOfClass'Humanoid'
			local Damage = M.RNG(minDam,maxDam)
			local canHit = true
			if(hum)then
				for _, p in pairs(Hit) do
					if p[1] == hum then
						if(time() - p[2] < 0.4) then
							canHit = false
						else
							Hit[_] = nil
						end
					end
				end
				if(canHit)then
					table.insert(Hit,{hum,time()})
					if(GetTorso(who))then
						Sound(GetTorso(who),406913243,1,10,false,true,true)
					end
					if(hum.Health >= math.huge)then
						Kill(who)
						if(who:FindFirstChild'Head' and hum.Health > 0)then
							ShowDamage((who.Head.CFrame * CF.N(0, 0, (who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), "INSTANT", 3, DamageColor.Color)
						end
					else
						local player = S.Players:GetPlayerFromCharacter(who)
						if(Type == "Fire")then
							--idk..
						else
							local  c = Instance.new("ObjectValue",hum)
							c.Name = "creator"
							c.Value = Plr
							game:service'Debris':AddItem(c,0.35)
							local Crit = false
							if(M.RNG(1,100) <= (critChance or 0) and critMult > 1)then
								Crit = true
								Damage = Damage*(critMult or 2)
							end
							Damage = Damage*((Souls/5)+1)
							if(who:FindFirstChild'Head' and hum.Health > 0)then
								ShowDamage((who.Head.CFrame * CF.N(0, 0, (who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), (Crit and "[CRIT] " or "").. math.floor(Damage), 3, (Crit and BrickColor.new'New Yeller'.Color or DamageColor.Color))
							end

							if(hum.Health - Damage <= 0)then
								Kill(who)
							else
								hum.Health = hum.Health - Damage
								if(Type == 'Knockback' and GetTorso(who))then
									local angle = GetTorso(who).Position - Root.Position + Vector3.new(0, 0, 0).unit
									local body = NewInstance('BodyVelocity',GetTorso(who),{
										P = 500,
										maxForce = V3.N(math.huge,0,math.huge),
										velocity = Root.CFrame.lookVector * Knock + Root.Velocity / 1.05
									})
									game:service'Debris':AddItem(body,.5)
								elseif(Type == "Electric")then
									if(M.RNG(1,100) >= critChance)then
										if(who:FindFirstChild'Head' and hum.Health > 0)then
											ShowDamage((who.Head.CFrame * CF.N(0, 0, (who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), "[PARALYZED]", 3, BrickColor.new"New Yeller".Color)
										end
										local asd = hum.WalkSpeed/2
										hum.WalkSpeed = asd
										local paralyzed = true
										coroutine.wrap(function()
											while paralyzed do
												swait(25)
												if(M.RNG(1,25) == 1)then
													if(who:FindFirstChild'Head' and hum.Health > 0)then
														ShowDamage((who.Head.CFrame * CF.N(0, 0, (who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), "[STATIC]", 3, BrickColor.new"New Yeller".Color)
													end
													hum.PlatformStand = true
												end
											end
										end)()
										delay(4, function()
											paralyzed = false
											hum.WalkSpeed = hum.WalkSpeed + asd
										end)
									end

								elseif(Type == 'Knockdown' and GetTorso(who))then
									local rek = GetTorso(who)
									hum.PlatformStand = true
									delay(1,function()
										hum.PlatformStand = false
									end)
									local angle = (GetTorso(who).Position - (Root.Position + Vector3.new(0, 0, 0))).unit
									local bodvol = NewInstance("BodyVelocity",rek,{
										velocity = angle * Knock,
										P = 5000,
										maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
									})
									local rl = NewInstance("BodyAngularVelocity",rek,{
										P = 3000,
										maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
										angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
									})
									game:GetService("Debris"):AddItem(bodvol, .5)
									game:GetService("Debris"):AddItem(rl, .5)
								end
							end
						end
					end
				end
			end
		end
	end


	function AOEDamage(where,range,minDam,maxDam,Knock,Type,critChance,critMult)
		for _,v in next, getRegion(where,range,{Char}) do
			if(v.Name ~= 'Nebula_Zorua')then
				if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid')then
					DealDamage(v.Parent,minDam,maxDam,Knock,Type,critChance,critMult)
				end
			end
		end
	end

	function AOEKill(where,range)
		for _,v in next, getRegion(where,range,{Char,Effects}) do
			local succ,alive = pcall(function() return v.Parent:FindFirstChildOfClass'Humanoid'.Health > 0 end)
			if(v.Name ~= 'Nebula_Zorua')then
				if(v.Parent and alive == true)then
					coroutine.wrap(Kill)(v.Parent)
				end
			end
		end
	end

	function AOEHeal(where,range,amount)
		local healed = {}
		for _,v in next, getRegion(where,range,{Char}) do
			local hum = (v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' or nil)
			if(hum and not healed[hum])then
				hum.Health = hum.Health + amount
				if(v.Parent:FindFirstChild'Head' and hum.Health > 0)then
					ShowDamage((v.Parent.Head.CFrame * CF.N(0, 0, (v.Parent.Head.Size.Z / 2)).p+V3.N(0,1.5,0)), "+"..amount, 1.5, BrickColor.new'Lime green'.Color)
				end
			end
		end
	end


	--// Attack Functions \\--


	function Slash()
		Attack = true
		NeutralAnims = false
		local sound = Sound(Knife,437475935,1,5,false,true,false)
		for i = 0, 2, 0.1 do
			swait()
			local Alpha = .2
			RJ.C0 = clerp(RJ.C0,CFrame.new(0.0343287587, 0.00629056804, 0.0572580174, 0.943793893, 0.00207689893, 0.330528289, 1.0000764e-06, 0.99998033, -0.00628630351, -0.330534875, 0.00593330665, 0.943775296),Alpha)
			LH.C0 = clerp(LH.C0,CFrame.new(-0.496478021, -0.990818381, 0.021652732, 0.999878168, 0, 0.0156089365, -9.80779296e-05, 0.99998033, 0.00628268253, -0.0156086385, -0.00628344761, 0.999858379),Alpha)
			RH.C0 = clerp(RH.C0,CFrame.new(0.498511612, -0.990985274, 0.0154910646, 0.999878168, 0, 0.0156089365, -9.80779296e-05, 0.99998033, 0.00628268253, -0.0156086385, -0.00628344761, 0.999858379),Alpha)
			LS.C0 = clerp(LS.C0,CFrame.new(-1.32692134, 0.474511296, -0.0055731535, 0.934981823, 0.354351997, 0.0156129003, -0.354479939, 0.93504262, 0.00628374517, -0.0123721063, -0.0114096552, 0.999858379),Alpha)
			RS.C0 = clerp(RS.C0,CFrame.new(1.12629449, 0.369358033, -0.486052871, 0.490151912, 0.65154773, 0.57899636, 0.721657813, 0.0691910982, -0.688783586, -0.488836735, 0.755445719, -0.436280251),Alpha)
			NK.C0 = clerp(NK.C0,CFrame.new(-0.0118216109, 1.49854016, -0.0795068145, 0.943793833, 0.0190048125, -0.329988182, 0.00207654224, 0.997985244, 0.0634154305, 0.330528468, -0.0605363287, 0.94185257),Alpha)
			HW.C0 = HW.C0:lerp(CF.N(0,-1,-1)*CF.A(M.R(-90),0,0),Alpha)
		end
		KTrail.Enabled = true
		sound:Play()
		for i = 0, 2.5, 0.1 do
			swait()
			AOEDamage(Knife.CFrame.p,1,15,30,0,"Normal",0,1)
			local Alpha = .25
			RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0352100767, 0.00629066909, -0.0097481478, 0.817972422, -0.00361463916, -0.575246274, -1.74103582e-06, 0.99998033, -0.00628598873, 0.575257719, 0.00514276745, 0.817956269),Alpha)
			LH.C0 = clerp(LH.C0,CFrame.new(-0.496478021, -0.990818381, 0.0216572341, 0.999878287, 0, 0.015610218, -9.80866607e-05, 0.99998033, 0.00628274865, -0.0156098902, -0.00628351374, 0.999858499),Alpha)
			RH.C0 = clerp(RH.C0,CFrame.new(0.498511702, -0.990985274, 0.0154905058, 0.999878287, 0, 0.015610218, -9.80866607e-05, 0.99998033, 0.00628274865, -0.0156098902, -0.00628351374, 0.999858499),Alpha)
			LS.C0 = clerp(LS.C0,CFrame.new(-1.32694602, 0.474510223, -0.00555660389, 0.934981823, 0.354351729, 0.0156157613, -0.354479671, 0.935042739, 0.00628153514, -0.012375474, -0.0114085823, 0.999858379),Alpha)
			RS.C0 = clerp(RS.C0,CFrame.new(1.23906493, 0.406229913, 0.00231830776, 0.49015066, -0.849889755, 0.193494052, 0.721655607, 0.520183682, 0.456752002, -0.488841236, -0.0842411816, 0.868295968),Alpha)
			NK.C0 = clerp(NK.C0,CFrame.new(0.0315471888, 1.49887729, -0.0257819965, 0.817972481, -0.0330747738, 0.574305832, -0.00361499586, 0.998030663, 0.0626262054, -0.575246155, -0.0533026271, 0.81624186),Alpha)
			HW.C0 = HW.C0:lerp(CF.N(0,-1,-1)*CF.A(M.R(-90),0,0),Alpha)
		end
		KTrail.Enabled = false
		Attack = false
		NeutralAnims = true
	end

	Mouse.Button1Down:connect(function()
		if(Attack)then return end
		Slash()	
	end)

	Mouse.KeyDown:connect(function(k)
		if(Attack)then return end
		if(k == 'z')then AOEKill(Root.CFrame.p,25) end -- TODO: Animation and effects
		if(k == 'q')then WalkSpeed = (WalkSpeed == 8 and 32 or 8) end	
	end)


	function Refuse()
		Attack = true
		warn("B u t  i t  r e f u s e d.")
		local oMH = MaxHealth
		MaxHealth = "inf"
		Hum.MaxHealth = "inf"
		Hum.Health = "inf"
		Char.Parent = nil
		Hum:destroy()
		if(not _G.RefusedAnimation)then
			_G.RefusedAnimation = true


			local Soul;
			function Soul(where,decalId)
				local destroy = false	
				local soul = NewInstance("Part",workspace)
				soul.Name = "Soul"
				soul.Transparency=1
				soul.Size = V3.N(2,2,.05)
				soul.Anchored=true
				soul.CanCollide=false
				soul.CFrame = where
				local heartF = NewInstance("Decal",soul,{Face=Enum.NormalId.Front,Texture="rbxassetid://"..decalId})
				local heartB = NewInstance("Decal",soul,{Face=Enum.NormalId.Back,Texture="rbxassetid://"..decalId})
				return soul,heartF,heartB
			end
			local owo = Root.CFrame
			local s,f,b = Soul(owo,1569347904)
			swait(60)
			local snd = Sound(s,862552636,1,5,false,false,false)
			snd:Play()
			f.Texture = "rbxassetid://1569348344"
			b.Texture = "rbxassetid://1569348344"
			swait(15)
			snd:Stop()
			swait(60)
			print'lol'
			for i = 0, 6, .1 do
				swait()
				s.CFrame = owo * CF.N(M.RNG(-50,50)/100,M.RNG(-50,50)/100,M.RNG(-50,50)/100)
			end
			local snd = Sound(s,862552636,1,5,false,false,false)
			snd:Play()
			s.CFrame = owo
			f.Texture = "rbxassetid://1569347904"
			b.Texture = "rbxassetid://1569347904"
			swait(15)
			snd:Stop()
			swait(60)

			s:destroy()
		end

		RJ.Parent = Char
		LS.Parent = Char
		RS.Parent = Char
		LH.Parent = Char
		RH.Parent = Char
		NK.Parent = Char

		LArm.Parent = Char
		RArm.Parent = Char
		LLeg.Parent = Char
		LArm.Parent = Char
		Root.Parent = Char
		Torso.Parent = Char
		Head.Parent = Char

		Knife.Parent = Char
		Hair.Parent = Char

		HW.Parent = Char
		HW2.Parent = Char


		REye:destroy()
		LEye:destroy()

		for _,v in next, Char:children() do
			if(v.Name == 'ShadowFace')then v:destroy() end
		end
		LEye = Part(Char,C3.N(1,0,0),Enum.Material.Neon,V3.N(.15,.25,.2),CF.N(),false,false)
		LEyeM = Mesh(LEye,Enum.MeshType.Sphere,"","",V3.N(1,1,1),V3.N())
		LEyeW = NewInstance("Weld",LEye,{Part0=Head,Part1=LEye,C0=CF.N(-.2,.2,-.49)})

		REye = Part(Char,C3.N(1,0,0),Enum.Material.Neon,V3.N(.15,.25,.2),CF.N(),false,false)
		REyeM = Mesh(REye,Enum.MeshType.Sphere,"","",V3.N(1,1,1),V3.N())
		REyeW = NewInstance("Weld",REye,{Part0=Head,Part1=REye,C0=CF.N(.2,.2,-.49)})
		for i = 1, 35 do
			local FACE = Part(Char,C3.N(0,0,0),Enum.Material.Neon,V3.N(1.01,.5,1.01),CF.N(),false,false)
			FACE.Transparency = 0+(i-1)/35.2
			FACE.Name = 'ShadowFace'
			Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
			NewInstance("Weld",Head,{Part0=Head,Part1=FACE,C0=CF.N(0,.35-(i-1)/75,0)})
			--CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0,0.35-(i-1)/75,0), CF(0, 0, 0))
		end
		Hum = NewInstance("Humanoid",Char,{DisplayDistanceType='None'})
		ConnectHum()
		MaxHealth = oMH
		Hum.MaxHealth = MaxHealth
		Hum.Health = MaxHealth
		swait(5)
		Char.Parent = workspace

		Attack = false
	end

	function ConnectHum()
		Hum.Died:connect(Refuse)
	end
	ConnectHum()


	--// Wrap it all up \\--
	while true do
		swait()
		Sine = Sine + Change
		if(not Music)then
			Music = Sound(Torso,MusicID,1,3,true,false,true)
			Music.Name = 'Music'
		end
		Music.Pitch = 1
		Music.Volume = 5
		Music.SoundId = "rbxassetid://"..MusicID
		Music.Parent = Torso
		Music:Resume()
		local hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * 4), Char)
		local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
		local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or not hitfloor and Root.Velocity.y < -1 and "Fall" or not hitfloor and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle")
		if(not Effects or not Effects.Parent)then
			Effects = IN("Model",Char)
			Effects.Name = "Effects"
		end
		Hum.WalkSpeed = WalkSpeed
		if(State == 'Walk')then
			if(Hum.WalkSpeed >= 24)then
				local wsVal = 22 / (Hum.WalkSpeed/16)
				local Alpha = math.min(.1 * (Hum.WalkSpeed/16),1)
				Change = 2
				RH.C1 = RH.C1:lerp(CF.N(0,1,0)*CF.N(0,0-.2*M.C(Sine/wsVal),0+.4*M.C(Sine/wsVal))*CF.A(M.R(25+45*M.C(Sine/wsVal))+-M.S(Sine/wsVal),0,0),Alpha)
				LH.C1 = LH.C1:lerp(CF.N(0,1,0)*CF.N(0,0+.2*M.C(Sine/wsVal),0-.4*M.C(Sine/wsVal))*CF.A(M.R(25-45*M.C(Sine/wsVal))+M.S(Sine/wsVal),0,0),Alpha)
			else
				Change = .9
				local wsVal = 8 / (Hum.WalkSpeed/8)
				local Alpha = math.min(.2 * (Hum.WalkSpeed/8),1)
				LH.C1 = LH.C1:lerp(CF.N(0,1-.2*M.C(Sine/wsVal)/2,.4*M.C(Sine/wsVal)/2)*CF.A(M.R(15-2*M.C(Sine/wsVal))-M.S(Sine/wsVal)/2.5,0,0)*CF.A(M.R(0-3*M.C(Sine/wsVal)),0,0),Alpha)
				RH.C1 = RH.C1:lerp(CF.N(0,1+.2*M.C(Sine/wsVal)/2,-.4*M.C(Sine/wsVal)/2)*CF.A(M.R(15+2*M.C(Sine/wsVal))+M.S(Sine/wsVal)/2.5,0,0)*CF.A(M.R(0+3*M.C(Sine/wsVal)),0,0),Alpha)
			end
		else
			RH.C1 = RH.C1:lerp(CF.N(0,1,0),.1)
			LH.C1 = LH.C1:lerp(CF.N(0,1,0),.1)
		end	
		for _,v in next, Char:children() do
			if(v:IsA'Accessory')then
				v:destroy()
			elseif(v:IsA'Shirt')then
				v.ShirtTemplate = "rbxassetid://344089667"
			elseif(v:IsA'Pants')then
				v.PantsTemplate = "rbxassetid://344084364"
			elseif(v:IsA'CharacterMesh')then
				v:destroy()
			elseif(v:FindFirstChildOfClass'ShirtGraphic')then
				v:FindFirstChildOfClass'ShirtGraphic':destroy()
			end
		end
		local face = Head:FindFirstChild'face'
		if(not face)then
			NewInstance("Decal",Head,{Name='face',Face=Enum.NormalId.Front,Texture="rbxassetid://404306534"})
		else
			face.Texture = "rbxassetid://404306534"
		end
		RArm.BrickColor = BrickColor.new'Pastel brown'
		LArm.BrickColor = BrickColor.new'Pastel brown'
		RLeg.BrickColor = BrickColor.new'Pastel brown'
		LLeg.BrickColor = BrickColor.new'Pastel brown'
		Torso.BrickColor = BrickColor.new'Pastel brown'
		Head.BrickColor = BrickColor.new'Pastel brown'
		Hum.Name = 'Chara'
		if(Hum.MaxHealth ~= MaxHealth)then
			Hum.MaxHealth = MaxHealth
		end
		Hum.DisplayDistanceType='None'
		if(NeutralAnims)then	
			if(State == 'Idle')then
				Change = 1
				local Alpha = .1
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0999571308, 0+.05*M.C(Sine/16), -0.237876296, 0.857335567, -0.00323621999, -0.514731407, 0, 0.99998033, -0.00628707698, 0.51474154, 0.00539013464, 0.85731858),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.536091685, -0.991042495-.05*M.C(Sine/16), -0.0134909991, 0.849195242, 0, 0.528063774, -0.00331997755, 0.99998033, 0.00533895614, -0.528053343, -0.00628707698, 0.849178433),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.529067397, -0.991597891-.05*M.C(Sine/16), -0.0818087086, 0.849195242, 0, 0.528063774, -0.00331997755, 0.99998033, 0.00533895614, -0.528053343, -0.00628707698, 0.849178433),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.32175505, 0.156236127+.15*M.C(Sine/16), 0.233877867, 0.877554953, -0.456876248, 0.145469457, 0.259513229, 0.707695842, 0.657129884, -0.403175086, -0.538916171, 0.739607573),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.2516855, 0.604915917+.15*M.C(Sine/16), -0.0189059302, 0.915104508, -0.287113011, -0.283108115, 0.301054537, 0.953587949, 0.00603589695, 0.268235415, -0.0907544345, 0.959069014),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(1.79447234e-05, 1.49895597, -0.0143749639, 0.769539058, -0.360377938, 0.527197778, 0.387706369, 0.919646919, 0.0627188534, -0.507438183, 0.156133309, 0.847424924),Alpha)
				HW.C0 = HW.C0:lerp(CF.N(0,-1,-1)*CF.A(M.R(-90),0,0),Alpha)
				-- idle
			elseif(State == 'Walk')then
				if(Hum.WalkSpeed >= 24)then
					local wsVal = 22 / (Hum.WalkSpeed/16)
					local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
					RJ.C0 = RJ.C0:lerp(CF.N(0,0-.15*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-15),M.R(0-15*M.S(Sine/wsVal)/2),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0-.3*M.S(Sine/wsVal))*CF.A(M.R(0+45*M.S(Sine/wsVal)),0,M.R(-5+15*M.S(Sine/wsVal))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0+.3*M.S(Sine/wsVal))*CF.A(M.R(0-45*M.S(Sine/wsVal)),0,M.R(5+15*M.S(Sine/wsVal))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(15),0,0),Alpha)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.15*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(15),0,0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.15*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(15),0,0),Alpha)
					HW.C0 = HW.C0:lerp(CF.N(0,-1,-1)*CF.A(M.R(-90),0,0),Alpha)
				else
					local wsVal = 8 / (Hum.WalkSpeed/8)
					local Alpha = math.min(.2 * (Hum.WalkSpeed/8),1)
					RJ.C0 = RJ.C0:lerp(CF.N(0,0-.05*M.C(Sine/(wsVal/2)),0)*CF.A(0,M.R(0-5*M.S(Sine/wsVal)/2),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0+.3*M.S(Sine/wsVal))*CF.A(M.R(0-25*M.S(Sine/wsVal)),0,M.R(5-5*M.S(Sine/wsVal))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0-.3*M.S(Sine/wsVal))*CF.A(M.R(0+25*M.S(Sine/wsVal)),0,M.R(-5-5*M.S(Sine/wsVal))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.05*M.C(Sine/(wsVal/2)),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.05*M.C(Sine/(wsVal/2)),0),Alpha)
					HW.C0 = HW.C0:lerp(CF.N(0,-1,-1)*CF.A(M.R(-90),0,0),Alpha)
				end
			elseif(State == 'Jump' or State == 'Fall')then
				if(Walking)then
					local Alpha = .2
					RJ.C0 = clerp(RJ.C0,RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(65)),M.R(65)),0,0),Alpha)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.497912645, -1.0987643, -0.0683324337, 0.999878228, 0.00860835519, 0.0130246133, -0.00010142161, 0.837816596, -0.545952022, -0.015611981, 0.545884132, 0.837715328),Alpha)
					RH.C0 = clerp(RH.C0,CFrame.new(0.499978393, -1.16382337, 0.109293163, 0.999878228, -0.0120433727, 0.00993486121, -0.00010142161, 0.631323814, 0.775519371, -0.015611981, -0.775425911, 0.631245613),Alpha)
					LS.C0 = clerp(LS.C0,CFrame.new(-1.55211556, 0.576563478, -0.00269976072, 0.976067662, 0.216906726, 0.0156116467, -0.217024669, 0.976145923, 0.00628317893, -0.0138763804, -0.00952091813, 0.999858499),Alpha)
					RS.C0 = clerp(RS.C0,CFrame.new(1.50182188, 0.636661649, 0.00632623257, 0.977592707, -0.209926367, 0.0156121543, 0.209851891, 0.977713108, 0.00628198683, -0.016582964, -0.00286500831, 0.999858439),Alpha)
					NK.C0 = clerp(NK.C0,CFrame.new(1.14440072e-05, 1.49924362, -0.0143961608, 1.00000024, -5.82076609e-11, 0, 1.23691279e-10, 0.997964919, 0.0637660474, 0, -0.0637660623, 0.997965038),Alpha)
					HW.C0 = HW.C0:lerp(CF.N(0,-1,-1)*CF.A(M.R(-90),0,0),Alpha)
				else
					local Alpha = .2
					RJ.C0 = clerp(RJ.C0,RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(65)),M.R(65)),0,0),Alpha)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.504374504, -0.291219354, -0.487436086, 0.999878228, -0.00438931212, 0.0149825988, -0.00010142161, 0.957819223, 0.287371844, -0.015611981, -0.287338346, 0.957701981),Alpha)
					RH.C0 = clerp(RH.C0,CFrame.new(0.453094482, -0.871358454, 0.0898642987, 0.985589385, -0.168456957, 0.0153662469, 0.162863791, 0.969548643, 0.182895929, -0.0457084104, -0.177757636, 0.983012319),Alpha)
					LS.C0 = clerp(LS.C0,CFrame.new(-1.55211556, 0.576563478, -0.00269976072, 0.976067662, 0.216906726, 0.0156116467, -0.217024669, 0.976145923, 0.00628317893, -0.0138763804, -0.00952091813, 0.999858499),Alpha)
					RS.C0 = clerp(RS.C0,CFrame.new(1.50182188, 0.636661649, 0.00632623257, 0.977592707, -0.209926367, 0.0156121543, 0.209851891, 0.977713108, 0.00628198683, -0.016582964, -0.00286500831, 0.999858439),Alpha)
					NK.C0 = clerp(NK.C0,CFrame.new(1.14440072e-05, 1.49924362, -0.0143961608, 1.00000024, -5.82076609e-11, 0, 1.23691279e-10, 0.997964919, 0.0637660474, 0, -0.0637660623, 0.997965038),Alpha)
					HW.C0 = HW.C0:lerp(CF.N(0,-1,-1)*CF.A(M.R(-90),0,0),Alpha)
				end
			elseif(State == 'Paralyzed')then
				-- paralyzed
			elseif(State == 'Sit')then
				-- sit
			end
		end
	end
end)

-- Scripts:

local function ITHZQ_fake_script() -- Frame.Dragable 
	local script = Instance.new('LocalScript', Frame)

	script.Parent.Active = true
	script.Parent.Draggable = true
end
coroutine.wrap(ITHZQ_fake_script)()
local function SXHCWLR_fake_script() -- Reanimate.LocalScript 
	local script = Instance.new('LocalScript', Reanimate)

	r,g,b,spd,tab=255,0,0,5,{}
	
	function findall(where) --get all textlabels or buttons
		for a,b in pairs(where:GetChildren()) do
			if (b.className:match('Label') or b.className:match('Button')) or b.className=='Frame' then
				table.insert(tab,b)
				findall(b)
			else findall(b) end
		end
	end
	
	setmetatable(tab,{
		__call=function(table,red,green,blue)
			for a,b in pairs(table) do
				b.BorderColor3=Color3.new(red/255,green/255,blue/255)
			end
		end
	})
	
	function rainbow()
		if r==255 and g<255 and b==0 then
			g=g+spd
		elseif r>0 and g==255 and b==0 then
			r=r-spd
		elseif r==0 and g==255 and b<255 then
			b=b+spd
		elseif r==0 and g>0 and b==255 then
			g=g-spd
		elseif r<255 and g==0 and b==255 then
			r=r+spd
		elseif r==255 and g==0 and b>0 then
			b=b-spd
		end
	end
	
	while true do
		findall(script.Parent)
		tab(r,g,b)
		rainbow()
		wait(spd/10000)
	end
	
end
coroutine.wrap(SXHCWLR_fake_script)()
